//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool from CryptoGateway Software Inc.
//     Tool name: CGW X-Script RDB visual Layer Generator
//
//     Archymeta Information Technologies Co., Ltd.
//
//     Changes to this file, could be overwritten if the code is re-generated.
//     Add (if not yet) a code-manager node to the generator to specify 
//     how existing files are processed.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Configuration;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;

namespace CryptoGateway.RDB.Data.MembershipPlus
{
    /// <summary>
    /// It is bound to webHttp end points accessed by javascript using json serialization method.
    /// </summary>
    /// <remarks>
    ///  <para>
    ///    Methods of the service are categorized in the following:
    ///  </para>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Adding, Updating or Removing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Adding, updating or removing entity graphs to or from data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IUserService.AddOrUpdateEntities" />, <see cref="IUserService.EnqueueNewOrUpdateEntities" />, and <see cref="IUserService.DeleteEntities" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Paged Listing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides paged listing of query results.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IUserService.NextPageBlock" /> and <see cref="IUserService.GetPageItems" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Query the data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IUserService.QueryEntityCount" />, <see cref="IUserService.QueryDatabase" />, <see cref="IUserService.QueryDatabaseLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity Lookup</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Find an entity from the corresponding entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IUserService.LoadEntityByKey" /> and <see cref="IUserService.LoadEntityByNature" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying Intelligency</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides a self-complete system for clients to construct query expressions. What completeness means here is that all options are included and 
    ///      no extra (to the query system) options are present.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IUserService.GetNextSorterOps" /> and <see cref="IUserService.GetNextFilterOps" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Downstream Navigation</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load and/or navigates to entity sets that depend on an entity in the current entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="IUserService.MaterializeAnnouncements" />, <see cref="IUserService.MaterializeCommunications" />, <see cref="IUserService.MaterializeEventCalendar_UserIDs" />, <see cref="IUserService.MaterializeEventCalendar_CreatedUserIDs" />, <see cref="IUserService.MaterializeMemberNotifications" />, <see cref="IUserService.MaterializeNotificationTaskSchedules" />, <see cref="IUserService.MaterializeShortMessageAudiences" />, <see cref="IUserService.MaterializeShortMessage_FromIDs" />, <see cref="IUserService.MaterializeShortMessage_ToIDs" />, <see cref="IUserService.MaterializeUserAppMembers" />, <see cref="IUserService.MaterializeUserAssociation_FromUserIDs" />, <see cref="IUserService.MaterializeUserAssociation_ToUserIDs" />, <see cref="IUserService.MaterializeUserAssocInvitation_FromUserIDs" />, <see cref="IUserService.MaterializeUserAssocInvitation_ToUserIDs" />, <see cref="IUserService.MaterializeUserDetails" />, <see cref="IUserService.MaterializeUserGroupMembers" />, <see cref="IUserService.MaterializeUserProfiles" />, <see cref="IUserService.MaterializeUsersInRole_UserIDs" />, <see cref="IUserService.MaterializeUsersInRole_AdminIDs" />, <see cref="IUserService.MaterializeUsersRoleHistory_UserIDs" />, <see cref="IUserService.MaterializeUsersRoleHistory_OperatorIDs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity graph building</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load a selected entity graph from the data source starting at an entity having specified primary key(s)
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="IUserService.LoadEntityGraphRecurs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    /// </remarks>
    [ServiceContract(Namespace = "http://relationaldb.archymeta.com/MembershipPlus/", SessionMode = SessionMode.Allowed)]
    public interface IUserService
    {
        /// <summary>
        ///   Retrieve information about the entity set: "Users". 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="UserSet" /> data model.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetSetInfo")]
        UserSet GetSetInfo(CallContext cntx, string filter);

        /// <summary>
        ///   Get a block of page frames from the entity set "Users" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="UserPageBlock" /> data model for entity set "Users".
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/NextPageBlock")]
        UserPageBlock NextPageBlock(CallContext cntx, UserSet set, QueryExpresion qexpr, User prevlast);

        /// <summary>
        ///   Load entities of a page from the entity set "Users" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="User" /> in set "Users" for the current page defined by "prevlast".
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetPageItems")]
        IEnumerable<User> GetPageItems(CallContext cntx, UserSet set, QueryExpresion qexpr, User prevlast);

        /// <summary>
        ///   Add or update a set of entities to the entity set. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="User" />) is modified or its <see cref="User.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="User.ChangedAnnouncements" />, <see cref="User.ChangedCommunications" />, <see cref="User.ChangedEventCalendar_UserIDs" />, <see cref="User.ChangedEventCalendar_CreatedUserIDs" />, <see cref="User.ChangedMemberNotifications" />, <see cref="User.ChangedNotificationTaskSchedules" />, <see cref="User.ChangedShortMessageAudiences" />, <see cref="User.ChangedShortMessage_FromIDs" />, <see cref="User.ChangedShortMessage_ToIDs" />, <see cref="User.ChangedUserAppMembers" />, <see cref="User.ChangedUserAssociation_FromUserIDs" />, <see cref="User.ChangedUserAssociation_ToUserIDs" />, <see cref="User.ChangedUserAssocInvitation_FromUserIDs" />, <see cref="User.ChangedUserAssocInvitation_ToUserIDs" />, <see cref="User.ChangedUserDetails" />, <see cref="User.ChangedUserGroupMembers" />, <see cref="User.ChangedUserProfiles" />, <see cref="User.ChangedUsersInRole_UserIDs" />, <see cref="User.ChangedUsersInRole_AdminIDs" />, <see cref="User.ChangedUsersRoleHistory_UserIDs" />, <see cref="User.ChangedUsersRoleHistory_OperatorIDs" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/AddOrUpdateEntities")]
        ChangeOpResults<UserUpdateResult> AddOrUpdateEntities(CallContext cntx, UserSet set, User[] entities);

        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="User" />) is modified or its <see cref="User.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="User.ChangedAnnouncements" />, <see cref="User.ChangedCommunications" />, <see cref="User.ChangedEventCalendar_UserIDs" />, <see cref="User.ChangedEventCalendar_CreatedUserIDs" />, <see cref="User.ChangedMemberNotifications" />, <see cref="User.ChangedNotificationTaskSchedules" />, <see cref="User.ChangedShortMessageAudiences" />, <see cref="User.ChangedShortMessage_FromIDs" />, <see cref="User.ChangedShortMessage_ToIDs" />, <see cref="User.ChangedUserAppMembers" />, <see cref="User.ChangedUserAssociation_FromUserIDs" />, <see cref="User.ChangedUserAssociation_ToUserIDs" />, <see cref="User.ChangedUserAssocInvitation_FromUserIDs" />, <see cref="User.ChangedUserAssocInvitation_ToUserIDs" />, <see cref="User.ChangedUserDetails" />, <see cref="User.ChangedUserGroupMembers" />, <see cref="User.ChangedUserProfiles" />, <see cref="User.ChangedUsersInRole_UserIDs" />, <see cref="User.ChangedUsersInRole_AdminIDs" />, <see cref="User.ChangedUsersRoleHistory_UserIDs" />, <see cref="User.ChangedUsersRoleHistory_OperatorIDs" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/EnqueueNewOrUpdateEntities")]
        void EnqueueNewOrUpdateEntities(CallContext cntx, UserSet set, User[] entities);

        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/DeleteEntities")]
        OperationResults DeleteEntities(CallContext cntx, UserSet set, User[] entities);

        /// <summary>
        ///   Count the number of entities inside entity set "Users" of the data source under specified filtering condition. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/QueryEntityCount")]
        Int64 QueryEntityCount(CallContext cntx, UserSet set, QueryExpresion qexpr);

        /// <summary>
        ///   Get the collection of entities of type <see cref="User" /> inside entity set "Users" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/QueryDatabase")]
        IEnumerable<User> QueryDatabase(CallContext cntx, UserSet set, QueryExpresion qexpr);

        /// <summary>
        ///   Get the collection of entities of type <see cref="User" /> inside entity set "Users" from the data source under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/QueryDatabaseLimited")]
        IEnumerable<User> QueryDatabaseLimited(CallContext cntx, UserSet set, QueryExpresion qexpr, int maxRecords);

        /// <summary>
        ///   Load the set of depending entities "Announcements" of type <see cref="AnnouncementSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="AnnouncementSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAnnouncements")]
        AnnouncementSet MaterializeAnnouncements(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllAnnouncements" of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllAnnouncements")]
        IEnumerable<Announcement> MaterializeAllAnnouncements(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "Communications" of type <see cref="CommunicationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeCommunications")]
        CommunicationSet MaterializeCommunications(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllCommunications" of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllCommunications")]
        IEnumerable<Communication> MaterializeAllCommunications(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "EventCalendar_UserIDs" of type <see cref="EventCalendarSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeEventCalendar_UserIDs")]
        EventCalendarSet MaterializeEventCalendar_UserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendar_UserIDs" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllEventCalendar_UserIDs")]
        IEnumerable<EventCalendar> MaterializeAllEventCalendar_UserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "EventCalendar_CreatedUserIDs" of type <see cref="EventCalendarSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeEventCalendar_CreatedUserIDs")]
        EventCalendarSet MaterializeEventCalendar_CreatedUserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendar_CreatedUserIDs" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllEventCalendar_CreatedUserIDs")]
        IEnumerable<EventCalendar> MaterializeAllEventCalendar_CreatedUserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "MemberNotifications" of type <see cref="MemberNotificationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="MemberNotificationSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeMemberNotifications")]
        MemberNotificationSet MaterializeMemberNotifications(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllMemberNotifications" of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllMemberNotifications")]
        IEnumerable<MemberNotification> MaterializeAllMemberNotifications(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "NotificationTaskSchedules" of type <see cref="NotificationTaskScheduleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="NotificationTaskScheduleSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeNotificationTaskSchedules")]
        NotificationTaskScheduleSet MaterializeNotificationTaskSchedules(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllNotificationTaskSchedules" of type <see cref="IEnumerable{NotificationTaskSchedule}" /> (T = <see cref="NotificationTaskSchedule" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{NotificationTaskSchedule}" /> (T = <see cref="NotificationTaskSchedule" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllNotificationTaskSchedules")]
        IEnumerable<NotificationTaskSchedule> MaterializeAllNotificationTaskSchedules(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "ShortMessageAudiences" of type <see cref="ShortMessageAudienceSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="ShortMessageAudienceSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeShortMessageAudiences")]
        ShortMessageAudienceSet MaterializeShortMessageAudiences(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllShortMessageAudiences" of type <see cref="IEnumerable{ShortMessageAudience}" /> (T = <see cref="ShortMessageAudience" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{ShortMessageAudience}" /> (T = <see cref="ShortMessageAudience" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllShortMessageAudiences")]
        IEnumerable<ShortMessageAudience> MaterializeAllShortMessageAudiences(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "ShortMessage_FromIDs" of type <see cref="ShortMessageSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="ShortMessageSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeShortMessage_FromIDs")]
        ShortMessageSet MaterializeShortMessage_FromIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllShortMessage_FromIDs" of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllShortMessage_FromIDs")]
        IEnumerable<ShortMessage> MaterializeAllShortMessage_FromIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "ShortMessage_ToIDs" of type <see cref="ShortMessageSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="ShortMessageSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeShortMessage_ToIDs")]
        ShortMessageSet MaterializeShortMessage_ToIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllShortMessage_ToIDs" of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllShortMessage_ToIDs")]
        IEnumerable<ShortMessage> MaterializeAllShortMessage_ToIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UserAppMembers" of type <see cref="UserAppMemberSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAppMemberSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserAppMembers")]
        UserAppMemberSet MaterializeUserAppMembers(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserAppMembers" of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserAppMembers")]
        IEnumerable<UserAppMember> MaterializeAllUserAppMembers(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UserAssociation_FromUserIDs" of type <see cref="UserAssociationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssociationSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserAssociation_FromUserIDs")]
        UserAssociationSet MaterializeUserAssociation_FromUserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssociation_FromUserIDs" of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserAssociation_FromUserIDs")]
        IEnumerable<UserAssociation> MaterializeAllUserAssociation_FromUserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of indirectly depending entities "PersonalRelationss" of type <see cref="UserSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializePersonalRelations")]
        UserSet MaterializePersonalRelations(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllPersonalRelationss" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllPersonalRelations")]
        IEnumerable<User> MaterializeAllPersonalRelations(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UserAssociation_ToUserIDs" of type <see cref="UserAssociationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssociationSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserAssociation_ToUserIDs")]
        UserAssociationSet MaterializeUserAssociation_ToUserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssociation_ToUserIDs" of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserAssociation_ToUserIDs")]
        IEnumerable<UserAssociation> MaterializeAllUserAssociation_ToUserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UserAssocInvitation_FromUserIDs" of type <see cref="UserAssocInvitationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssocInvitationSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserAssocInvitation_FromUserIDs")]
        UserAssocInvitationSet MaterializeUserAssocInvitation_FromUserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssocInvitation_FromUserIDs" of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserAssocInvitation_FromUserIDs")]
        IEnumerable<UserAssocInvitation> MaterializeAllUserAssocInvitation_FromUserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UserAssocInvitation_ToUserIDs" of type <see cref="UserAssocInvitationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssocInvitationSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserAssocInvitation_ToUserIDs")]
        UserAssocInvitationSet MaterializeUserAssocInvitation_ToUserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssocInvitation_ToUserIDs" of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserAssocInvitation_ToUserIDs")]
        IEnumerable<UserAssocInvitation> MaterializeAllUserAssocInvitation_ToUserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of indirectly depending entities "InvitatingUserss" of type <see cref="UserSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeInvitatingUsers")]
        UserSet MaterializeInvitatingUsers(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllInvitatingUserss" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllInvitatingUsers")]
        IEnumerable<User> MaterializeAllInvitatingUsers(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UserDetails" of type <see cref="UserDetailSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserDetailSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserDetails")]
        UserDetailSet MaterializeUserDetails(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserDetails" of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserDetails")]
        IEnumerable<UserDetail> MaterializeAllUserDetails(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UserGroupMembers" of type <see cref="UserGroupMemberSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserGroupMemberSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserGroupMembers")]
        UserGroupMemberSet MaterializeUserGroupMembers(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserGroupMembers" of type <see cref="IEnumerable{UserGroupMember}" /> (T = <see cref="UserGroupMember" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserGroupMember}" /> (T = <see cref="UserGroupMember" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserGroupMembers")]
        IEnumerable<UserGroupMember> MaterializeAllUserGroupMembers(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UserProfiles" of type <see cref="UserProfileSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserProfileSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserProfiles")]
        UserProfileSet MaterializeUserProfiles(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUserProfiles" of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUserProfiles")]
        IEnumerable<UserProfile> MaterializeAllUserProfiles(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UsersInRole_UserIDs" of type <see cref="UsersInRoleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersInRoleSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUsersInRole_UserIDs")]
        UsersInRoleSet MaterializeUsersInRole_UserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUsersInRole_UserIDs" of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUsersInRole_UserIDs")]
        IEnumerable<UsersInRole> MaterializeAllUsersInRole_UserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of indirectly depending entities "Roless" of type <see cref="RoleSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="RoleSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeRoles")]
        RoleSet MaterializeRoles(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllRoless" of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllRoles")]
        IEnumerable<Role> MaterializeAllRoles(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UsersInRole_AdminIDs" of type <see cref="UsersInRoleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersInRoleSet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUsersInRole_AdminIDs")]
        UsersInRoleSet MaterializeUsersInRole_AdminIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUsersInRole_AdminIDs" of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUsersInRole_AdminIDs")]
        IEnumerable<UsersInRole> MaterializeAllUsersInRole_AdminIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UsersRoleHistory_UserIDs" of type <see cref="UsersRoleHistorySet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersRoleHistorySet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUsersRoleHistory_UserIDs")]
        UsersRoleHistorySet MaterializeUsersRoleHistory_UserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUsersRoleHistory_UserIDs" of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUsersRoleHistory_UserIDs")]
        IEnumerable<UsersRoleHistory> MaterializeAllUsersRoleHistory_UserIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the set of depending entities "UsersRoleHistory_OperatorIDs" of type <see cref="UsersRoleHistorySet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersRoleHistorySet" />.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUsersRoleHistory_OperatorIDs")]
        UsersRoleHistorySet MaterializeUsersRoleHistory_OperatorIDs(CallContext cntx, User entity);

        /// <summary>
        ///   Load the collection of depending entities "AllUsersRoleHistory_OperatorIDs" of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />).
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeAllUsersRoleHistory_OperatorIDs")]
        IEnumerable<UsersRoleHistory> MaterializeAllUsersRoleHistory_OperatorIDs(CallContext cntx, User entity);

        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="User.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="User.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/LoadEntityByKey")]
        User LoadEntityByKey(CallContext cntx, string _ID);

        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="User.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="User.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/LoadEntityGraphRecurs")]
        User LoadEntityGraphRecurs(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets);

        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="User.Username" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_Username">Intrinsic id <see cref="User.Username" />.</param>
        /// <remarks>
        ///  <para>
        ///   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
        ///   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
        ///   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
        ///   system.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   The list of found entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/LoadEntityByNature")]
        List<User> LoadEntityByNature(CallContext cntx, string _Username);

        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetNextSorterOps")]
        TokenOptions GetNextSorterOps(CallContext cntx, List<QToken> sorters);

        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetNextFilterOps")]
        TokenOptions GetNextFilterOps(CallContext cntx, QueryExpresion qexpr, string tkstr);

    }

    /// <summary>
    /// It is bound to basicHttp end points accessed by clients other than a web browser.
    /// </summary>
    /// <remarks>
    ///  <para>
    ///    Methods of the service are categorized in the following:
    ///  </para>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Adding, Updating or Removing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Adding, updating or removing entity graphs to or from data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IUserService2.AddOrUpdateEntities" />, <see cref="IUserService2.EnqueueNewOrUpdateEntities" />, and <see cref="IUserService2.DeleteEntities" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Paged Listing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides paged listing of query results.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IUserService2.NextPageBlock" /> and <see cref="IUserService2.GetPageItems" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Query the data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IUserService2.QueryEntityCount" />, <see cref="IUserService2.QueryDatabase" />, <see cref="IUserService2.QueryDatabaseLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity Lookup</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Find an entity from the corresponding entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IUserService2.LoadEntityByKey" /> and <see cref="IUserService2.LoadEntityByNature" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying Intelligency</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides a self-complete system for clients to construct query expressions. What completeness means here is that all options are included and 
    ///      no extra (to the query system) options are present.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="IUserService2.GetNextSorterOps" /> and <see cref="IUserService2.GetNextFilterOps" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Downstream Navigation</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load and/or navigates to entity sets that depend on an entity in the current entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="IUserService2.MaterializeAnnouncements" />, <see cref="IUserService2.MaterializeCommunications" />, <see cref="IUserService2.MaterializeEventCalendar_UserIDs" />, <see cref="IUserService2.MaterializeEventCalendar_CreatedUserIDs" />, <see cref="IUserService2.MaterializeMemberNotifications" />, <see cref="IUserService2.MaterializeNotificationTaskSchedules" />, <see cref="IUserService2.MaterializeShortMessageAudiences" />, <see cref="IUserService2.MaterializeShortMessage_FromIDs" />, <see cref="IUserService2.MaterializeShortMessage_ToIDs" />, <see cref="IUserService2.MaterializeUserAppMembers" />, <see cref="IUserService2.MaterializeUserAssociation_FromUserIDs" />, <see cref="IUserService2.MaterializeUserAssociation_ToUserIDs" />, <see cref="IUserService2.MaterializeUserAssocInvitation_FromUserIDs" />, <see cref="IUserService2.MaterializeUserAssocInvitation_ToUserIDs" />, <see cref="IUserService2.MaterializeUserDetails" />, <see cref="IUserService2.MaterializeUserGroupMembers" />, <see cref="IUserService2.MaterializeUserProfiles" />, <see cref="IUserService2.MaterializeUsersInRole_UserIDs" />, <see cref="IUserService2.MaterializeUsersInRole_AdminIDs" />, <see cref="IUserService2.MaterializeUsersRoleHistory_UserIDs" />, <see cref="IUserService2.MaterializeUsersRoleHistory_OperatorIDs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity graph building</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load a selected entity graph from the data source starting at an entity having specified primary key(s)
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="IUserService2.LoadEntityGraphRecurs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    /// </remarks>
    [ServiceContract(Namespace = "http://relationaldb.archymeta.com/MembershipPlus/", SessionMode = SessionMode.Allowed)]
    public interface IUserService2
    {
        /// <summary>
        ///   Retrieve information about the entity set: "Users". 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="UserSet" /> data model.
        /// </returns>
        [OperationContract]
        UserSet GetSetInfo(CallContext cntx, string filter);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Retrieve information about the entity set: "Users". Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="UserSet" /> data model.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserSet> GetSetInfoAsync(CallContext cntx, string filter);
#endif

        /// <summary>
        ///   Get a block of page frames from the entity set "Users" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="UserPageBlock" /> data model for entity set "Users".
        /// </returns>
        [OperationContract]
        UserPageBlock NextPageBlock(CallContext cntx, UserSet set, QueryExpresion qexpr, User prevlast);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get a block of page frames from the entity set "Users" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="UserPageBlock" /> data model for entity set "Users".
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserPageBlock> NextPageBlockAsync(CallContext cntx, UserSet set, QueryExpresion qexpr, User prevlast);
#endif

        /// <summary>
        ///   Load entities of a page from the entity set "Users" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="User" /> in set "Users" for the current page defined by "prevlast".
        /// </returns>
        [OperationContract]
        IEnumerable<User> GetPageItems(CallContext cntx, UserSet set, QueryExpresion qexpr, User prevlast);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load entities of a page from the entity set "Users" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="User" /> in set "Users" for the current page defined by "prevlast".
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<User>> GetPageItemsAsync(CallContext cntx, UserSet set, QueryExpresion qexpr, User prevlast);
#endif

        /// <summary>
        ///   Add or update a set of entities to the entity set. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="User" />) is modified or its <see cref="User.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="User.ChangedAnnouncements" />, <see cref="User.ChangedCommunications" />, <see cref="User.ChangedEventCalendar_UserIDs" />, <see cref="User.ChangedEventCalendar_CreatedUserIDs" />, <see cref="User.ChangedMemberNotifications" />, <see cref="User.ChangedNotificationTaskSchedules" />, <see cref="User.ChangedShortMessageAudiences" />, <see cref="User.ChangedShortMessage_FromIDs" />, <see cref="User.ChangedShortMessage_ToIDs" />, <see cref="User.ChangedUserAppMembers" />, <see cref="User.ChangedUserAssociation_FromUserIDs" />, <see cref="User.ChangedUserAssociation_ToUserIDs" />, <see cref="User.ChangedUserAssocInvitation_FromUserIDs" />, <see cref="User.ChangedUserAssocInvitation_ToUserIDs" />, <see cref="User.ChangedUserDetails" />, <see cref="User.ChangedUserGroupMembers" />, <see cref="User.ChangedUserProfiles" />, <see cref="User.ChangedUsersInRole_UserIDs" />, <see cref="User.ChangedUsersInRole_AdminIDs" />, <see cref="User.ChangedUsersRoleHistory_UserIDs" />, <see cref="User.ChangedUsersRoleHistory_OperatorIDs" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        [OperationContract]
        ChangeOpResults<UserUpdateResult> AddOrUpdateEntities(CallContext cntx, UserSet set, User[] entities);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Add or update a set of entities to the entity set. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="User" />) is modified or its <see cref="User.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="User.ChangedAnnouncements" />, <see cref="User.ChangedCommunications" />, <see cref="User.ChangedEventCalendar_UserIDs" />, <see cref="User.ChangedEventCalendar_CreatedUserIDs" />, <see cref="User.ChangedMemberNotifications" />, <see cref="User.ChangedNotificationTaskSchedules" />, <see cref="User.ChangedShortMessageAudiences" />, <see cref="User.ChangedShortMessage_FromIDs" />, <see cref="User.ChangedShortMessage_ToIDs" />, <see cref="User.ChangedUserAppMembers" />, <see cref="User.ChangedUserAssociation_FromUserIDs" />, <see cref="User.ChangedUserAssociation_ToUserIDs" />, <see cref="User.ChangedUserAssocInvitation_FromUserIDs" />, <see cref="User.ChangedUserAssocInvitation_ToUserIDs" />, <see cref="User.ChangedUserDetails" />, <see cref="User.ChangedUserGroupMembers" />, <see cref="User.ChangedUserProfiles" />, <see cref="User.ChangedUsersInRole_UserIDs" />, <see cref="User.ChangedUsersInRole_AdminIDs" />, <see cref="User.ChangedUsersRoleHistory_UserIDs" />, <see cref="User.ChangedUsersRoleHistory_OperatorIDs" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<ChangeOpResults<UserUpdateResult>> AddOrUpdateEntitiesAsync(CallContext cntx, UserSet set, User[] entities);
#endif

        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="User" />) is modified or its <see cref="User.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="User.ChangedAnnouncements" />, <see cref="User.ChangedCommunications" />, <see cref="User.ChangedEventCalendar_UserIDs" />, <see cref="User.ChangedEventCalendar_CreatedUserIDs" />, <see cref="User.ChangedMemberNotifications" />, <see cref="User.ChangedNotificationTaskSchedules" />, <see cref="User.ChangedShortMessageAudiences" />, <see cref="User.ChangedShortMessage_FromIDs" />, <see cref="User.ChangedShortMessage_ToIDs" />, <see cref="User.ChangedUserAppMembers" />, <see cref="User.ChangedUserAssociation_FromUserIDs" />, <see cref="User.ChangedUserAssociation_ToUserIDs" />, <see cref="User.ChangedUserAssocInvitation_FromUserIDs" />, <see cref="User.ChangedUserAssocInvitation_ToUserIDs" />, <see cref="User.ChangedUserDetails" />, <see cref="User.ChangedUserGroupMembers" />, <see cref="User.ChangedUserProfiles" />, <see cref="User.ChangedUsersInRole_UserIDs" />, <see cref="User.ChangedUsersInRole_AdminIDs" />, <see cref="User.ChangedUsersRoleHistory_UserIDs" />, <see cref="User.ChangedUsersRoleHistory_OperatorIDs" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        [OperationContract]
        void EnqueueNewOrUpdateEntities(CallContext cntx, UserSet set, User[] entities);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="User" />) is modified or its <see cref="User.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="User.ChangedAnnouncements" />, <see cref="User.ChangedCommunications" />, <see cref="User.ChangedEventCalendar_UserIDs" />, <see cref="User.ChangedEventCalendar_CreatedUserIDs" />, <see cref="User.ChangedMemberNotifications" />, <see cref="User.ChangedNotificationTaskSchedules" />, <see cref="User.ChangedShortMessageAudiences" />, <see cref="User.ChangedShortMessage_FromIDs" />, <see cref="User.ChangedShortMessage_ToIDs" />, <see cref="User.ChangedUserAppMembers" />, <see cref="User.ChangedUserAssociation_FromUserIDs" />, <see cref="User.ChangedUserAssociation_ToUserIDs" />, <see cref="User.ChangedUserAssocInvitation_FromUserIDs" />, <see cref="User.ChangedUserAssocInvitation_ToUserIDs" />, <see cref="User.ChangedUserDetails" />, <see cref="User.ChangedUserGroupMembers" />, <see cref="User.ChangedUserProfiles" />, <see cref="User.ChangedUsersInRole_UserIDs" />, <see cref="User.ChangedUsersInRole_AdminIDs" />, <see cref="User.ChangedUsersRoleHistory_UserIDs" />, <see cref="User.ChangedUsersRoleHistory_OperatorIDs" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task EnqueueNewOrUpdateEntitiesAsync(CallContext cntx, UserSet set, User[] entities);
#endif

        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        [OperationContract]
        OperationResults DeleteEntities(CallContext cntx, UserSet set, User[] entities);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<OperationResults> DeleteEntitiesAsync(CallContext cntx, UserSet set, User[] entities);
#endif

        /// <summary>
        ///   Count the number of entities inside entity set "Users" of the data source under specified filtering condition. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        Int64 QueryEntityCount(CallContext cntx, UserSet set, QueryExpresion qexpr);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Count the number of entities inside entity set "Users" of the data source under specified filtering condition. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Int64> QueryEntityCountAsync(CallContext cntx, UserSet set, QueryExpresion qexpr);
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="User" /> inside entity set "Users" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        IEnumerable<User> QueryDatabase(CallContext cntx, UserSet set, QueryExpresion qexpr);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="User" /> inside entity set "Users" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<User>> QueryDatabaseAsync(CallContext cntx, UserSet set, QueryExpresion qexpr);
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="User" /> inside entity set "Users" from the data source under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        IEnumerable<User> QueryDatabaseLimited(CallContext cntx, UserSet set, QueryExpresion qexpr, int maxRecords);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="User" /> inside entity set "Users" from the data source under specified filtering, sorting and max number of returning entities conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<User>> QueryDatabaseLimitedAsync(CallContext cntx, UserSet set, QueryExpresion qexpr, int maxRecords);
#endif

        /// <summary>
        ///   Load the set of depending entities "Announcements" of type <see cref="AnnouncementSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="AnnouncementSet" />.
        /// </returns>
        [OperationContract]
        AnnouncementSet MaterializeAnnouncements(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "Announcements" of type <see cref="AnnouncementSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="AnnouncementSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<AnnouncementSet> MaterializeAnnouncementsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllAnnouncements" of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />).
        /// </returns>
        [OperationContract]
        IEnumerable<Announcement> MaterializeAllAnnouncements(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllAnnouncements" of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Announcement>> MaterializeAllAnnouncementsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "Communications" of type <see cref="CommunicationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationSet" />.
        /// </returns>
        [OperationContract]
        CommunicationSet MaterializeCommunications(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "Communications" of type <see cref="CommunicationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<CommunicationSet> MaterializeCommunicationsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllCommunications" of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />).
        /// </returns>
        [OperationContract]
        IEnumerable<Communication> MaterializeAllCommunications(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllCommunications" of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Communication>> MaterializeAllCommunicationsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "EventCalendar_UserIDs" of type <see cref="EventCalendarSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        [OperationContract]
        EventCalendarSet MaterializeEventCalendar_UserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "EventCalendar_UserIDs" of type <see cref="EventCalendarSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<EventCalendarSet> MaterializeEventCalendar_UserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendar_UserIDs" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        [OperationContract]
        IEnumerable<EventCalendar> MaterializeAllEventCalendar_UserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendar_UserIDs" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<EventCalendar>> MaterializeAllEventCalendar_UserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "EventCalendar_CreatedUserIDs" of type <see cref="EventCalendarSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        [OperationContract]
        EventCalendarSet MaterializeEventCalendar_CreatedUserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "EventCalendar_CreatedUserIDs" of type <see cref="EventCalendarSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<EventCalendarSet> MaterializeEventCalendar_CreatedUserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendar_CreatedUserIDs" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        [OperationContract]
        IEnumerable<EventCalendar> MaterializeAllEventCalendar_CreatedUserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendar_CreatedUserIDs" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<EventCalendar>> MaterializeAllEventCalendar_CreatedUserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "MemberNotifications" of type <see cref="MemberNotificationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="MemberNotificationSet" />.
        /// </returns>
        [OperationContract]
        MemberNotificationSet MaterializeMemberNotifications(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "MemberNotifications" of type <see cref="MemberNotificationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="MemberNotificationSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<MemberNotificationSet> MaterializeMemberNotificationsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllMemberNotifications" of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />).
        /// </returns>
        [OperationContract]
        IEnumerable<MemberNotification> MaterializeAllMemberNotifications(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllMemberNotifications" of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<MemberNotification>> MaterializeAllMemberNotificationsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "NotificationTaskSchedules" of type <see cref="NotificationTaskScheduleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="NotificationTaskScheduleSet" />.
        /// </returns>
        [OperationContract]
        NotificationTaskScheduleSet MaterializeNotificationTaskSchedules(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "NotificationTaskSchedules" of type <see cref="NotificationTaskScheduleSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="NotificationTaskScheduleSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<NotificationTaskScheduleSet> MaterializeNotificationTaskSchedulesAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllNotificationTaskSchedules" of type <see cref="IEnumerable{NotificationTaskSchedule}" /> (T = <see cref="NotificationTaskSchedule" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{NotificationTaskSchedule}" /> (T = <see cref="NotificationTaskSchedule" />).
        /// </returns>
        [OperationContract]
        IEnumerable<NotificationTaskSchedule> MaterializeAllNotificationTaskSchedules(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllNotificationTaskSchedules" of type <see cref="IEnumerable{NotificationTaskSchedule}" /> (T = <see cref="NotificationTaskSchedule" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{NotificationTaskSchedule}" /> (T = <see cref="NotificationTaskSchedule" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<NotificationTaskSchedule>> MaterializeAllNotificationTaskSchedulesAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "ShortMessageAudiences" of type <see cref="ShortMessageAudienceSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="ShortMessageAudienceSet" />.
        /// </returns>
        [OperationContract]
        ShortMessageAudienceSet MaterializeShortMessageAudiences(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "ShortMessageAudiences" of type <see cref="ShortMessageAudienceSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="ShortMessageAudienceSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<ShortMessageAudienceSet> MaterializeShortMessageAudiencesAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllShortMessageAudiences" of type <see cref="IEnumerable{ShortMessageAudience}" /> (T = <see cref="ShortMessageAudience" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{ShortMessageAudience}" /> (T = <see cref="ShortMessageAudience" />).
        /// </returns>
        [OperationContract]
        IEnumerable<ShortMessageAudience> MaterializeAllShortMessageAudiences(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllShortMessageAudiences" of type <see cref="IEnumerable{ShortMessageAudience}" /> (T = <see cref="ShortMessageAudience" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{ShortMessageAudience}" /> (T = <see cref="ShortMessageAudience" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<ShortMessageAudience>> MaterializeAllShortMessageAudiencesAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "ShortMessage_FromIDs" of type <see cref="ShortMessageSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="ShortMessageSet" />.
        /// </returns>
        [OperationContract]
        ShortMessageSet MaterializeShortMessage_FromIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "ShortMessage_FromIDs" of type <see cref="ShortMessageSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="ShortMessageSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<ShortMessageSet> MaterializeShortMessage_FromIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllShortMessage_FromIDs" of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />).
        /// </returns>
        [OperationContract]
        IEnumerable<ShortMessage> MaterializeAllShortMessage_FromIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllShortMessage_FromIDs" of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<ShortMessage>> MaterializeAllShortMessage_FromIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "ShortMessage_ToIDs" of type <see cref="ShortMessageSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="ShortMessageSet" />.
        /// </returns>
        [OperationContract]
        ShortMessageSet MaterializeShortMessage_ToIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "ShortMessage_ToIDs" of type <see cref="ShortMessageSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="ShortMessageSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<ShortMessageSet> MaterializeShortMessage_ToIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllShortMessage_ToIDs" of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />).
        /// </returns>
        [OperationContract]
        IEnumerable<ShortMessage> MaterializeAllShortMessage_ToIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllShortMessage_ToIDs" of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{ShortMessage}" /> (T = <see cref="ShortMessage" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<ShortMessage>> MaterializeAllShortMessage_ToIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAppMembers" of type <see cref="UserAppMemberSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAppMemberSet" />.
        /// </returns>
        [OperationContract]
        UserAppMemberSet MaterializeUserAppMembers(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAppMembers" of type <see cref="UserAppMemberSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAppMemberSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserAppMemberSet> MaterializeUserAppMembersAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAppMembers" of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserAppMember> MaterializeAllUserAppMembers(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAppMembers" of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserAppMember>> MaterializeAllUserAppMembersAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAssociation_FromUserIDs" of type <see cref="UserAssociationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssociationSet" />.
        /// </returns>
        [OperationContract]
        UserAssociationSet MaterializeUserAssociation_FromUserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAssociation_FromUserIDs" of type <see cref="UserAssociationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssociationSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserAssociationSet> MaterializeUserAssociation_FromUserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssociation_FromUserIDs" of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserAssociation> MaterializeAllUserAssociation_FromUserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAssociation_FromUserIDs" of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserAssociation>> MaterializeAllUserAssociation_FromUserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of indirectly depending entities "PersonalRelationss" of type <see cref="UserSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        [OperationContract]
        UserSet MaterializePersonalRelations(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of indirectly depending entities "PersonalRelationss" of type <see cref="UserSet" /> of an entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserSet> MaterializePersonalRelationsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllPersonalRelationss" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        [OperationContract]
        IEnumerable<User> MaterializeAllPersonalRelations(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of indirectly depending entities "AllPersonalRelationss" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<User>> MaterializeAllPersonalRelationsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAssociation_ToUserIDs" of type <see cref="UserAssociationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssociationSet" />.
        /// </returns>
        [OperationContract]
        UserAssociationSet MaterializeUserAssociation_ToUserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAssociation_ToUserIDs" of type <see cref="UserAssociationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssociationSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserAssociationSet> MaterializeUserAssociation_ToUserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssociation_ToUserIDs" of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserAssociation> MaterializeAllUserAssociation_ToUserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAssociation_ToUserIDs" of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserAssociation>> MaterializeAllUserAssociation_ToUserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAssocInvitation_FromUserIDs" of type <see cref="UserAssocInvitationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssocInvitationSet" />.
        /// </returns>
        [OperationContract]
        UserAssocInvitationSet MaterializeUserAssocInvitation_FromUserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAssocInvitation_FromUserIDs" of type <see cref="UserAssocInvitationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssocInvitationSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserAssocInvitationSet> MaterializeUserAssocInvitation_FromUserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssocInvitation_FromUserIDs" of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserAssocInvitation> MaterializeAllUserAssocInvitation_FromUserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAssocInvitation_FromUserIDs" of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserAssocInvitation>> MaterializeAllUserAssocInvitation_FromUserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAssocInvitation_ToUserIDs" of type <see cref="UserAssocInvitationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssocInvitationSet" />.
        /// </returns>
        [OperationContract]
        UserAssocInvitationSet MaterializeUserAssocInvitation_ToUserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAssocInvitation_ToUserIDs" of type <see cref="UserAssocInvitationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssocInvitationSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserAssocInvitationSet> MaterializeUserAssocInvitation_ToUserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssocInvitation_ToUserIDs" of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserAssocInvitation> MaterializeAllUserAssocInvitation_ToUserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAssocInvitation_ToUserIDs" of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserAssocInvitation>> MaterializeAllUserAssocInvitation_ToUserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of indirectly depending entities "InvitatingUserss" of type <see cref="UserSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        [OperationContract]
        UserSet MaterializeInvitatingUsers(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of indirectly depending entities "InvitatingUserss" of type <see cref="UserSet" /> of an entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserSet> MaterializeInvitatingUsersAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllInvitatingUserss" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        [OperationContract]
        IEnumerable<User> MaterializeAllInvitatingUsers(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of indirectly depending entities "AllInvitatingUserss" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<User>> MaterializeAllInvitatingUsersAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserDetails" of type <see cref="UserDetailSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserDetailSet" />.
        /// </returns>
        [OperationContract]
        UserDetailSet MaterializeUserDetails(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserDetails" of type <see cref="UserDetailSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserDetailSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserDetailSet> MaterializeUserDetailsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserDetails" of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserDetail> MaterializeAllUserDetails(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserDetails" of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserDetail>> MaterializeAllUserDetailsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserGroupMembers" of type <see cref="UserGroupMemberSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserGroupMemberSet" />.
        /// </returns>
        [OperationContract]
        UserGroupMemberSet MaterializeUserGroupMembers(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserGroupMembers" of type <see cref="UserGroupMemberSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserGroupMemberSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserGroupMemberSet> MaterializeUserGroupMembersAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserGroupMembers" of type <see cref="IEnumerable{UserGroupMember}" /> (T = <see cref="UserGroupMember" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserGroupMember}" /> (T = <see cref="UserGroupMember" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserGroupMember> MaterializeAllUserGroupMembers(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserGroupMembers" of type <see cref="IEnumerable{UserGroupMember}" /> (T = <see cref="UserGroupMember" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserGroupMember}" /> (T = <see cref="UserGroupMember" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserGroupMember>> MaterializeAllUserGroupMembersAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UserProfiles" of type <see cref="UserProfileSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserProfileSet" />.
        /// </returns>
        [OperationContract]
        UserProfileSet MaterializeUserProfiles(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserProfiles" of type <see cref="UserProfileSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserProfileSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UserProfileSet> MaterializeUserProfilesAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserProfiles" of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UserProfile> MaterializeAllUserProfiles(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserProfiles" of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UserProfile>> MaterializeAllUserProfilesAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UsersInRole_UserIDs" of type <see cref="UsersInRoleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersInRoleSet" />.
        /// </returns>
        [OperationContract]
        UsersInRoleSet MaterializeUsersInRole_UserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UsersInRole_UserIDs" of type <see cref="UsersInRoleSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersInRoleSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UsersInRoleSet> MaterializeUsersInRole_UserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUsersInRole_UserIDs" of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UsersInRole> MaterializeAllUsersInRole_UserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUsersInRole_UserIDs" of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UsersInRole>> MaterializeAllUsersInRole_UserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of indirectly depending entities "Roless" of type <see cref="RoleSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="RoleSet" />.
        /// </returns>
        [OperationContract]
        RoleSet MaterializeRoles(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of indirectly depending entities "Roless" of type <see cref="RoleSet" /> of an entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="RoleSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<RoleSet> MaterializeRolesAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllRoless" of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />).
        /// </returns>
        [OperationContract]
        IEnumerable<Role> MaterializeAllRoles(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of indirectly depending entities "AllRoless" of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Role>> MaterializeAllRolesAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UsersInRole_AdminIDs" of type <see cref="UsersInRoleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersInRoleSet" />.
        /// </returns>
        [OperationContract]
        UsersInRoleSet MaterializeUsersInRole_AdminIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UsersInRole_AdminIDs" of type <see cref="UsersInRoleSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersInRoleSet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UsersInRoleSet> MaterializeUsersInRole_AdminIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUsersInRole_AdminIDs" of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UsersInRole> MaterializeAllUsersInRole_AdminIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUsersInRole_AdminIDs" of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UsersInRole>> MaterializeAllUsersInRole_AdminIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UsersRoleHistory_UserIDs" of type <see cref="UsersRoleHistorySet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersRoleHistorySet" />.
        /// </returns>
        [OperationContract]
        UsersRoleHistorySet MaterializeUsersRoleHistory_UserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UsersRoleHistory_UserIDs" of type <see cref="UsersRoleHistorySet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersRoleHistorySet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UsersRoleHistorySet> MaterializeUsersRoleHistory_UserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUsersRoleHistory_UserIDs" of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UsersRoleHistory> MaterializeAllUsersRoleHistory_UserIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUsersRoleHistory_UserIDs" of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UsersRoleHistory>> MaterializeAllUsersRoleHistory_UserIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the set of depending entities "UsersRoleHistory_OperatorIDs" of type <see cref="UsersRoleHistorySet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersRoleHistorySet" />.
        /// </returns>
        [OperationContract]
        UsersRoleHistorySet MaterializeUsersRoleHistory_OperatorIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UsersRoleHistory_OperatorIDs" of type <see cref="UsersRoleHistorySet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersRoleHistorySet" />.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<UsersRoleHistorySet> MaterializeUsersRoleHistory_OperatorIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUsersRoleHistory_OperatorIDs" of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />).
        /// </returns>
        [OperationContract]
        IEnumerable<UsersRoleHistory> MaterializeAllUsersRoleHistory_OperatorIDs(CallContext cntx, User entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUsersRoleHistory_OperatorIDs" of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />).
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<UsersRoleHistory>> MaterializeAllUsersRoleHistory_OperatorIDsAsync(CallContext cntx, User entity);
#endif

        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="User.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="User.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        [OperationContract]
        User LoadEntityByKey(CallContext cntx, string _ID);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="User.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="User.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<User> LoadEntityByKeyAsync(CallContext cntx, string _ID);
#endif

        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="User.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="User.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        [OperationContract]
        User LoadEntityGraphRecurs(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="User.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="User.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<User> LoadEntityGraphRecursAsync(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets);
#endif

        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="User.Username" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_Username">Intrinsic id <see cref="User.Username" />.</param>
        /// <remarks>
        ///  <para>
        ///   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
        ///   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
        ///   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
        ///   system.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   The list of found entities.
        /// </returns>
        [OperationContract]
        List<User> LoadEntityByNature(CallContext cntx, string _Username);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="User.Username" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_Username">Intrinsic id <see cref="User.Username" />.</param>
        /// <remarks>
        ///  <para>
        ///   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
        ///   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
        ///   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
        ///   system.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   The list of found entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<List<User>> LoadEntityByNatureAsync(CallContext cntx, string _Username);
#endif

        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        [OperationContract]
        TokenOptions GetNextSorterOps(CallContext cntx, List<QToken> sorters);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<TokenOptions> GetNextSorterOpsAsync(CallContext cntx, List<QToken> sorters);
#endif

        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        [OperationContract]
        TokenOptions GetNextFilterOps(CallContext cntx, QueryExpresion qexpr, string tkstr);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<TokenOptions> GetNextFilterOpsAsync(CallContext cntx, QueryExpresion qexpr, string tkstr);
#endif

    }

}
