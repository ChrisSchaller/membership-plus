//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool from CryptoGateway Software Inc.
//     Tool name: CGW X-Script RDB visual Layer Generator
//
//     Archymeta Information Technologies Co., Ltd.
//
//     Changes to this file, could be overwritten if the code is re-generated.
//     Add (if not yet) a code-manager node to the generator to specify 
//     how existing files are processed.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Configuration;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;

namespace CryptoGateway.RDB.Data.MembershipPlus
{
    /// <summary>
    /// It is bound to webHttp end points accessed by javascript using json serialization method.
    /// </summary>
    /// <remarks>
    ///  <para>
    ///    Methods of the service are categorized in the following:
    ///  </para>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Adding, Updating or Removing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Adding, updating or removing entity graphs to or from data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService.AddOrUpdateEntities" />, <see cref="ICommunicationService.EnqueueNewOrUpdateEntities" />, and <see cref="ICommunicationService.DeleteEntities" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Paged Listing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides paged listing of query results.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService.NextPageBlock" /> and <see cref="ICommunicationService.GetPageItems" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Query the data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService.QueryEntityCount" />, <see cref="ICommunicationService.QueryDatabase" />, <see cref="ICommunicationService.QueryDatabaseLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity Lookup</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Find an entity from the corresponding entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService.LoadEntityByKey" /> and <see cref="ICommunicationService.LoadEntityByNature" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Conditioned Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        When entities in an entity set depends on entities in other sets, query the data source under condition that some or all the entities that the current entity set depends on
    ///      are given.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService.ConstraintQueryEntityCount" />, <see cref="ICommunicationService.ConstraintQuery" />, <see cref="ICommunicationService.ConstraintQueryLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying Intelligency</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides a self-complete system for clients to construct query expressions. What completeness means here is that all options are included and 
    ///      no extra (to the query system) options are present.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService.GetNextSorterOps" /> and <see cref="ICommunicationService.GetNextFilterOps" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Delay Loaded Properties</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Properties that are loaded on demand.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods (loading)</term>
    ///      <description>
    ///         <see cref="ICommunicationService.LoadEntityComment" />
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods (uploading)</term>
    ///      <description>
    ///         <see cref="ICommunicationService.UpdateEntityComment" />
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Upstream Navigation</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load and/or navigates to entities an entity in the current entity set depends upon.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="ICommunicationService.MaterializeApplication_Ref" />, <see cref="ICommunicationService.MaterializeCommunicationTypeRef" />, <see cref="ICommunicationService.MaterializeUserRef" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity graph building</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load a selected entity graph from the data source starting at an entity having specified primary key(s)
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="ICommunicationService.LoadEntityGraphRecurs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    /// </remarks>
    [ServiceContract(Namespace = "http://relationaldb.archymeta.com/MembershipPlus/", SessionMode = SessionMode.Allowed)]
    public interface ICommunicationService
    {
        /// <summary>
        ///   Retrieve information about the entity set: "Communications". 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="CommunicationSet" /> data model.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetSetInfo")]
        CommunicationSet GetSetInfo(CallContext cntx, string filter);

        /// <summary>
        ///   Get a block of page frames from the entity set "Communications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="CommunicationPageBlock" /> data model for entity set "Communications".
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/NextPageBlock")]
        CommunicationPageBlock NextPageBlock(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, Communication prevlast);

        /// <summary>
        ///   Load entities of a page from the entity set "Communications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="Communication" /> in set "Communications" for the current page defined by "prevlast".
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetPageItems")]
        IEnumerable<Communication> GetPageItems(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, Communication prevlast);

        /// <summary>
        ///   Add or update a set of entities to the entity set. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Communication" />) is modified or its <see cref="Communication.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="Communication.Application_Ref" />, <see cref="Communication.CommunicationTypeRef" />, <see cref="Communication.UserRef" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/AddOrUpdateEntities")]
        ChangeOpResults<CommunicationUpdateResult> AddOrUpdateEntities(CallContext cntx, CommunicationSet set, Communication[] entities);

        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Communication" />) is modified or its <see cref="Communication.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="Communication.Application_Ref" />, <see cref="Communication.CommunicationTypeRef" />, <see cref="Communication.UserRef" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/EnqueueNewOrUpdateEntities")]
        void EnqueueNewOrUpdateEntities(CallContext cntx, CommunicationSet set, Communication[] entities);

        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/DeleteEntities")]
        OperationResults DeleteEntities(CallContext cntx, CommunicationSet set, Communication[] entities);

        /// <summary>
        ///   Count the number of entities inside entity set "Communications" of the data source under specified filtering condition. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/QueryEntityCount")]
        Int64 QueryEntityCount(CallContext cntx, CommunicationSet set, QueryExpresion qexpr);

        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/QueryDatabase")]
        IEnumerable<Communication> QueryDatabase(CallContext cntx, CommunicationSet set, QueryExpresion qexpr);

        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" from the data source under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/QueryDatabaseLimited")]
        IEnumerable<Communication> QueryDatabaseLimited(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, int maxRecords);

        /// <summary>
        ///   Get the number of entities from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/ConstraintQueryEntityCount")]
        Int64 ConstraintQueryEntityCount(CallContext cntx, CommunicationSet set, CommunicationSetConstraints constraints, QueryExpresion qexpr);

        /// <summary>
        ///   Given a set of foreign key constraints, find the ones that has non zero corresponding entities. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="cnstSets">A collection of sets of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   A set of constraint pointer that has non-zero corresponding entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/ConstraintsFindMatches")]
        ConstraintsPtr[] ConstraintsFindMatches(CallContext cntx, CommunicationSet set, CommunicationSetConstraints[] cnstSets, QueryExpresion qexpr);

        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/ConstraintQuery")]
        IEnumerable<Communication> ConstraintQuery(CallContext cntx, CommunicationSet set, CommunicationSetConstraints constraints, QueryExpresion qexpr);

        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" of the data source restricted by a set of specified foreign key values and under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/ConstraintQueryLimited")]
        IEnumerable<Communication> ConstraintQueryLimited(CallContext cntx, CommunicationSet set, CommunicationSetConstraints constraints, QueryExpresion qexpr, int maxRecords);

        /// <summary>
        ///   Load the entity "Application_Ref" of type <see cref="Application_" /> that the entity depend upon. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="Application_" /> or null.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeApplication_Ref")]
        Application_ MaterializeApplication_Ref(CallContext cntx, Communication entity);

        /// <summary>
        ///   Load the entity "CommunicationTypeRef" of type <see cref="CommunicationType" /> that the entity depend upon. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationType" /> or null.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeCommunicationTypeRef")]
        CommunicationType MaterializeCommunicationTypeRef(CallContext cntx, Communication entity);

        /// <summary>
        ///   Load the entity "UserRef" of type <see cref="User" /> that the entity depend upon. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="User" /> or null.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/MaterializeUserRef")]
        User MaterializeUserRef(CallContext cntx, Communication entity);

        /// <summary>
        ///   Get the collection of non-trivial foreign key constrains of type <see cref="Communication" /> inside entity set "Communications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Filter expression for the set.</param>
        /// <param name="max">Number of items per page.</param>
        /// <param name="nextId">The id of next page, if any.</param>
        /// <returns>
        ///   The collection of independent non-trivial foreign key constrains.
        /// </returns>
        /// <remarks>It will throw an exception if the <see cref="CommunicationSet.SetFilter" /> of <paramref name="set" /> is null or empty.</remarks>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/QuerySetConstraints")]
        CommunicationSetConstraintsColl QuerySetConstraints(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, int max, string nextId);

        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="Communication.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/LoadEntityByKey")]
        Communication LoadEntityByKey(CallContext cntx, string _ID);

        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="Communication.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/LoadEntityGraphRecurs")]
        Communication LoadEntityGraphRecurs(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets);

        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="Communication.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Intrinsic id <see cref="Communication.ID" />.</param>
        /// <remarks>
        ///  <para>
        ///   The returned entity set should contain zero or one item or null.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Null or zero or one entity.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/LoadEntityByNature")]
        List<Communication> LoadEntityByNature(CallContext cntx, string _ID);

        /// <summary>
        ///  Load the delay loaded property <see cref="Communication.Comment" />. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <remarks>
        /// </remarks>
        /// <returns>
        ///   The value of the property.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/LoadEntityComment")]
        string LoadEntityComment(CallContext cntx, string _ID);

        /// <summary>
        ///  Update the delay loaded property <see cref="Communication.Comment" />. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <param name="data">The updated value.</param>
        /// <remarks>
        /// </remarks>
        /// <returns>
        ///   The value of the property.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/UpdateEntityComment")]
        void UpdateEntityComment(CallContext cntx, string _ID, string data);

        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetNextSorterOps")]
        TokenOptions GetNextSorterOps(CallContext cntx, List<QToken> sorters);

        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        [OperationContract]
        [WebInvoke(Method = "POST",
            RequestFormat = WebMessageFormat.Json,
            ResponseFormat = WebMessageFormat.Json,
            BodyStyle = WebMessageBodyStyle.Wrapped,
            UriTemplate = "/GetNextFilterOps")]
        TokenOptions GetNextFilterOps(CallContext cntx, QueryExpresion qexpr, string tkstr);

    }

    /// <summary>
    /// It is bound to basicHttp end points accessed by clients other than a web browser.
    /// </summary>
    /// <remarks>
    ///  <para>
    ///    Methods of the service are categorized in the following:
    ///  </para>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Adding, Updating or Removing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Adding, updating or removing entity graphs to or from data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService2.AddOrUpdateEntities" />, <see cref="ICommunicationService2.EnqueueNewOrUpdateEntities" />, and <see cref="ICommunicationService2.DeleteEntities" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Paged Listing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides paged listing of query results.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService2.NextPageBlock" /> and <see cref="ICommunicationService2.GetPageItems" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Query the data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService2.QueryEntityCount" />, <see cref="ICommunicationService2.QueryDatabase" />, <see cref="ICommunicationService2.QueryDatabaseLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity Lookup</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Find an entity from the corresponding entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService2.LoadEntityByKey" /> and <see cref="ICommunicationService2.LoadEntityByNature" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Conditioned Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        When entities in an entity set depends on entities in other sets, query the data source under condition that some or all the entities that the current entity set depends on
    ///      are given.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService2.ConstraintQueryEntityCount" />, <see cref="ICommunicationService2.ConstraintQuery" />, <see cref="ICommunicationService2.ConstraintQueryLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying Intelligency</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides a self-complete system for clients to construct query expressions. What completeness means here is that all options are included and 
    ///      no extra (to the query system) options are present.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="ICommunicationService2.GetNextSorterOps" /> and <see cref="ICommunicationService2.GetNextFilterOps" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Delay Loaded Properties</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Properties that are loaded on demand.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods (loading)</term>
    ///      <description>
    ///         <see cref="ICommunicationService2.LoadEntityComment" />
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods (uploading)</term>
    ///      <description>
    ///         <see cref="ICommunicationService2.UpdateEntityComment" />
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Upstream Navigation</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load and/or navigates to entities an entity in the current entity set depends upon.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="ICommunicationService2.MaterializeApplication_Ref" />, <see cref="ICommunicationService2.MaterializeCommunicationTypeRef" />, <see cref="ICommunicationService2.MaterializeUserRef" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity graph building</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load a selected entity graph from the data source starting at an entity having specified primary key(s)
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="ICommunicationService2.LoadEntityGraphRecurs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    /// </remarks>
    [ServiceContract(Namespace = "http://relationaldb.archymeta.com/MembershipPlus/", SessionMode = SessionMode.Allowed)]
    public interface ICommunicationService2
    {
        /// <summary>
        ///   Retrieve information about the entity set: "Communications". 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="CommunicationSet" /> data model.
        /// </returns>
        [OperationContract]
        CommunicationSet GetSetInfo(CallContext cntx, string filter);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Retrieve information about the entity set: "Communications". Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="CommunicationSet" /> data model.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<CommunicationSet> GetSetInfoAsync(CallContext cntx, string filter);
#endif

        /// <summary>
        ///   Get a block of page frames from the entity set "Communications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="CommunicationPageBlock" /> data model for entity set "Communications".
        /// </returns>
        [OperationContract]
        CommunicationPageBlock NextPageBlock(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, Communication prevlast);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get a block of page frames from the entity set "Communications" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="CommunicationPageBlock" /> data model for entity set "Communications".
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<CommunicationPageBlock> NextPageBlockAsync(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, Communication prevlast);
#endif

        /// <summary>
        ///   Load entities of a page from the entity set "Communications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="Communication" /> in set "Communications" for the current page defined by "prevlast".
        /// </returns>
        [OperationContract]
        IEnumerable<Communication> GetPageItems(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, Communication prevlast);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load entities of a page from the entity set "Communications" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="Communication" /> in set "Communications" for the current page defined by "prevlast".
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Communication>> GetPageItemsAsync(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, Communication prevlast);
#endif

        /// <summary>
        ///   Add or update a set of entities to the entity set. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Communication" />) is modified or its <see cref="Communication.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="Communication.Application_Ref" />, <see cref="Communication.CommunicationTypeRef" />, <see cref="Communication.UserRef" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        [OperationContract]
        ChangeOpResults<CommunicationUpdateResult> AddOrUpdateEntities(CallContext cntx, CommunicationSet set, Communication[] entities);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Add or update a set of entities to the entity set. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Communication" />) is modified or its <see cref="Communication.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="Communication.Application_Ref" />, <see cref="Communication.CommunicationTypeRef" />, <see cref="Communication.UserRef" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<ChangeOpResults<CommunicationUpdateResult>> AddOrUpdateEntitiesAsync(CallContext cntx, CommunicationSet set, Communication[] entities);
#endif

        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Communication" />) is modified or its <see cref="Communication.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="Communication.Application_Ref" />, <see cref="Communication.CommunicationTypeRef" />, <see cref="Communication.UserRef" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        [OperationContract]
        void EnqueueNewOrUpdateEntities(CallContext cntx, CommunicationSet set, Communication[] entities);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="Communication" />) is modified or its <see cref="Communication.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="Communication.Application_Ref" />, <see cref="Communication.CommunicationTypeRef" />, <see cref="Communication.UserRef" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task EnqueueNewOrUpdateEntitiesAsync(CallContext cntx, CommunicationSet set, Communication[] entities);
#endif

        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        [OperationContract]
        OperationResults DeleteEntities(CallContext cntx, CommunicationSet set, Communication[] entities);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<OperationResults> DeleteEntitiesAsync(CallContext cntx, CommunicationSet set, Communication[] entities);
#endif

        /// <summary>
        ///   Count the number of entities inside entity set "Communications" of the data source under specified filtering condition. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        Int64 QueryEntityCount(CallContext cntx, CommunicationSet set, QueryExpresion qexpr);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Count the number of entities inside entity set "Communications" of the data source under specified filtering condition. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Int64> QueryEntityCountAsync(CallContext cntx, CommunicationSet set, QueryExpresion qexpr);
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        IEnumerable<Communication> QueryDatabase(CallContext cntx, CommunicationSet set, QueryExpresion qexpr);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Communication>> QueryDatabaseAsync(CallContext cntx, CommunicationSet set, QueryExpresion qexpr);
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" from the data source under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        IEnumerable<Communication> QueryDatabaseLimited(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, int maxRecords);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" from the data source under specified filtering, sorting and max number of returning entities conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Communication>> QueryDatabaseLimitedAsync(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, int maxRecords);
#endif

        /// <summary>
        ///   Get the number of entities from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        Int64 ConstraintQueryEntityCount(CallContext cntx, CommunicationSet set, CommunicationSetConstraints constraints, QueryExpresion qexpr);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the number of entities from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Int64> ConstraintQueryEntityCountAsync(CallContext cntx, CommunicationSet set, CommunicationSetConstraints constraints, QueryExpresion qexpr);
#endif

        /// <summary>
        ///   Given a set of foreign key constraints, find the ones that has non zero corresponding entities. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="cnstSets">A collection of sets of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   A set of constraint pointer that has non-zero corresponding entities.
        /// </returns>
        [OperationContract]
        ConstraintsPtr[] ConstraintsFindMatches(CallContext cntx, CommunicationSet set, CommunicationSetConstraints[] cnstSets, QueryExpresion qexpr);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Given a set of foreign key constraints, find the ones that has non zero corresponding entities. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="cnstSets">A collection of sets of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   A set of constraint pointer that has non-zero corresponding entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<ConstraintsPtr[]> ConstraintsFindMatchesAsync(CallContext cntx, CommunicationSet set, CommunicationSetConstraints[] cnstSets, QueryExpresion qexpr);
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        IEnumerable<Communication> ConstraintQuery(CallContext cntx, CommunicationSet set, CommunicationSetConstraints constraints, QueryExpresion qexpr);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Communication>> ConstraintQueryAsync(CallContext cntx, CommunicationSet set, CommunicationSetConstraints constraints, QueryExpresion qexpr);
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" of the data source restricted by a set of specified foreign key values and under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        IEnumerable<Communication> ConstraintQueryLimited(CallContext cntx, CommunicationSet set, CommunicationSetConstraints constraints, QueryExpresion qexpr, int maxRecords);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="Communication" /> inside entity set "Communications" of the data source restricted by a set of specified foreign key values and under specified filtering, sorting and max number of returning entities conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "Communications" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<IEnumerable<Communication>> ConstraintQueryLimitedAsync(CallContext cntx, CommunicationSet set, CommunicationSetConstraints constraints, QueryExpresion qexpr, int maxRecords);
#endif

        /// <summary>
        ///   Load the entity "Application_Ref" of type <see cref="Application_" /> that the entity depend upon. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="Application_" /> or null.
        /// </returns>
        [OperationContract]
        Application_ MaterializeApplication_Ref(CallContext cntx, Communication entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the entity "Application_Ref" of type <see cref="Application_" /> that the entity depend upon. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="Application_" /> or null.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Application_> MaterializeApplication_RefAsync(CallContext cntx, Communication entity);
#endif

        /// <summary>
        ///   Load the entity "CommunicationTypeRef" of type <see cref="CommunicationType" /> that the entity depend upon. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationType" /> or null.
        /// </returns>
        [OperationContract]
        CommunicationType MaterializeCommunicationTypeRef(CallContext cntx, Communication entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the entity "CommunicationTypeRef" of type <see cref="CommunicationType" /> that the entity depend upon. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationType" /> or null.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<CommunicationType> MaterializeCommunicationTypeRefAsync(CallContext cntx, Communication entity);
#endif

        /// <summary>
        ///   Load the entity "UserRef" of type <see cref="User" /> that the entity depend upon. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="User" /> or null.
        /// </returns>
        [OperationContract]
        User MaterializeUserRef(CallContext cntx, Communication entity);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the entity "UserRef" of type <see cref="User" /> that the entity depend upon. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="User" /> or null.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<User> MaterializeUserRefAsync(CallContext cntx, Communication entity);
#endif

        /// <summary>
        ///   Get the collection of non-trivial foreign key constrains of type <see cref="Communication" /> inside entity set "Communications" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Filter expression for the set.</param>
        /// <param name="max">Number of items per page.</param>
        /// <param name="nextId">The id of next page, if any.</param>
        /// <returns>
        ///   The collection of independent non-trivial foreign key constrains.
        /// </returns>
        /// <remarks>It will throw an exception if the <see cref="CommunicationSet.SetFilter" /> of <paramref name="set" /> is null or empty.</remarks>
        [OperationContract]
        CommunicationSetConstraintsColl QuerySetConstraints(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, int max, string nextId);
#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of non-trivial foreign key constrains of type <see cref="Communication" /> inside entity set "Communications" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Filter expression for the set.</param>
        /// <param name="max">Number of items per page.</param>
        /// <param name="nextId">The id of next page, if any.</param>
        /// <returns>
        ///   The collection of independent non-trivial foreign key constrains.
        /// </returns>
        /// <remarks>It will throw an exception if the <see cref="CommunicationSet.SetFilter" /> of <paramref name="set" /> is null or empty.</remarks>
        [OperationContract]
        System.Threading.Tasks.Task<CommunicationSetConstraintsColl> QuerySetConstraintsAsync(CallContext cntx, CommunicationSet set, QueryExpresion qexpr, int max, string nextId);
#endif

        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="Communication.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        [OperationContract]
        Communication LoadEntityByKey(CallContext cntx, string _ID);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="Communication.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Communication> LoadEntityByKeyAsync(CallContext cntx, string _ID);
#endif

        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="Communication.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        [OperationContract]
        Communication LoadEntityGraphRecurs(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="Communication.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<Communication> LoadEntityGraphRecursAsync(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets);
#endif

        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="Communication.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Intrinsic id <see cref="Communication.ID" />.</param>
        /// <remarks>
        ///  <para>
        ///   The returned entity set should contain zero or one item or null.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Null or zero or one entity.
        /// </returns>
        [OperationContract]
        List<Communication> LoadEntityByNature(CallContext cntx, string _ID);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="Communication.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Intrinsic id <see cref="Communication.ID" />.</param>
        /// <remarks>
        ///  <para>
        ///   The returned entity set should contain zero or one item or null.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Null or zero or one entity.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<List<Communication>> LoadEntityByNatureAsync(CallContext cntx, string _ID);
#endif

        /// <summary>
        ///  Load the delay loaded property <see cref="Communication.Comment" />. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <remarks>
        /// </remarks>
        /// <returns>
        ///   The value of the property.
        /// </returns>
        [OperationContract]
        string LoadEntityComment(CallContext cntx, string _ID);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Load the delay loaded property <see cref="Communication.Comment" />. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <remarks>
        /// </remarks>
        /// <returns>
        ///   The value of the property.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<string> LoadEntityCommentAsync(CallContext cntx, string _ID);
#endif

        /// <summary>
        ///  Update the delay loaded property <see cref="Communication.Comment" />. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <param name="data">The updated value.</param>
        /// <remarks>
        /// </remarks>
        /// <returns>
        ///   The value of the property.
        /// </returns>
        [OperationContract]
        void UpdateEntityComment(CallContext cntx, string _ID, string data);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Update the delay loaded property <see cref="Communication.Comment" />. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="Communication.ID" />.</param>
        /// <param name="data">The updated value.</param>
        /// <remarks>
        /// </remarks>
        /// <returns>
        ///   The value of the property.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task UpdateEntityCommentAsync(CallContext cntx, string _ID, string data);
#endif

        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        [OperationContract]
        TokenOptions GetNextSorterOps(CallContext cntx, List<QToken> sorters);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<TokenOptions> GetNextSorterOpsAsync(CallContext cntx, List<QToken> sorters);
#endif

        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        [OperationContract]
        TokenOptions GetNextFilterOps(CallContext cntx, QueryExpresion qexpr, string tkstr);
#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        [OperationContract]
        System.Threading.Tasks.Task<TokenOptions> GetNextFilterOpsAsync(CallContext cntx, QueryExpresion qexpr, string tkstr);
#endif

    }

}
