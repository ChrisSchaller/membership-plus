//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool from CryptoGateway Software Inc.
//     Tool name: CGW X-Script RDB visual Layer Generator
//
//     Archymeta Information Technologies Co., Ltd.
//
//     Changes to this file, could be overwritten if the code is re-generated.
//     Add (if not yet) a code-manager node to the generator to specify 
//     how existing files are processed.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Configuration;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;

namespace CryptoGateway.RDB.Data.MembershipPlus
{
    [DataContract]
    public enum AppLogLevel
    {
        [EnumMember]
        Debug = 1,
        [EnumMember]
        Info = 2,
        [EnumMember]
        Warn = 3,
        [EnumMember]
        Error = 4,
        [EnumMember]
        Fatal = 5,
    }

    /// <summary>
    /// A class holding accumulative operation messages from the service.
    /// </summary>
    [DataContract]
    public class OperationResults
    {
        /// <summary>
        /// A list of messages.
        /// </summary>
        [DataMember]
        public List<string> OpMsgs
        {
            get;
            set;
        }
    }

    /// <summary>
    /// A class holding user credentials for authentication purposes.
    /// </summary>
    [DataContract]
    public class CallerCredentials
    {
        /// <summary>
        /// The user-name to identify the client.
        /// </summary>
        [DataMember]
        public string UserName_
        {
            get;
            set;
        }

        /// <summary>
        /// The password used to sign-in the service, if needed.
        /// </summary>
        [DataMember]
        public string Password_
        {
            get;
            set;
        }
        //...
    }

    /// <summary>
    /// A class representing a client and carrying client specific data.
    /// An instance of this class must be initiated from the service side by clients calling
    /// <see cref="IMembershipPlusService.SignInService" /> or <see cref="IMembershipPlusService2.SignInService" />, 
    /// saved by the clients, and be used on all subsequent calls to the service.
    /// </summary>
    [DataContract]
    public class CallContext
    {
        /// <summary>
        /// Internal use only.
        /// </summary>
        /// <param name="set">The entity name corresponding to data set.</param>
        /// <returns>
        ///   The key for caches.
        /// </returns>
        public string CacheKey(string set)
        {
            if (FilterTable.Count == 0)
                return "";
            else
            {
                List<QToken> qexprs;
                if (FilterTable.TryGetValue(set, out qexprs))
                {
                    string key = "";
                    foreach (var tk in qexprs)
                        key += tk.TkName + "|";
                    return key;
                }
                else
                    return "";
            }
        }

        /// <summary>
        /// The identifier of the client (the caller). For authenticated client, it is most-likely the <see cref="CallerCredentials.UserName_" />.
        /// </summary>
        [DataMember]
        public string CallerID
        {
            get
            {
                return !string.IsNullOrEmpty(_callerID) ? _callerID : "anonymous";
            }
            set
            {
                _callerID = value;
            }
        }
        private string _callerID = null;

        /// <summary>
        /// A session id for the client assigned by the service.
        /// </summary>
        [DataMember]
        public string SessionID
        {
            get;
            set;
        }

        /// <summary>
        /// A serialized and encripted data containing client specific data for security management of the service. It expires at a certain time after
        /// being issued by the service.
        /// </summary>
        [DataMember]
        public string SecurityTicket
        {
            get;
            set;
        }

        /// <summary>
        /// Client and data set specific filter expression used to control the scope of data access of the client.
        /// </summary>
        /// <param name="set">The entity name corresponding to data set.</param>
        /// <returns>
        ///   String expression of the filter
        /// </returns>
        public string ContextFilter(string set)
        {
            return null;
        }

        /// <summary>
        /// Client and data set specific structured (or parsed) filter expression used to control the scope of data access of the client.
        /// </summary>
        /// <param name="set">The entity name corresponding to data set.</param>
        /// <returns>
        ///   Structured filter expression.
        /// </returns>
        public object ContextFilterExpr(string set)
        {
            object obj;
            if (FilterExprTable.TryGetValue(set, out obj))
                return obj;
            else 
                return null;
        }

        /// <summary>
        /// Internal user only.
        /// </summary>
        public Dictionary<string, List<QToken>> FilterTable
        {
            get
            {
                if (_filterTable == null)
                    _filterTable = new Dictionary<string, List<QToken>>();
                return _filterTable;
            }
        }
        private Dictionary<string, List<QToken>> _filterTable = null;

        /// <summary>
        /// Internal user only.
        /// </summary>
        public Dictionary<string, object> FilterExprTable
        {
            get
            {
                if (_filterExprTable_ == null)
                    _filterExprTable_ = new Dictionary<string, object>();
                return _filterExprTable_;
            }
        }
        private Dictionary<string, object> _filterExprTable_ = null;

        /// <summary>
        /// Internal user only.
        /// </summary>
        public object CurrentDBContext
        {
            get;
            set;
        }

        /// <summary>
        /// Internal user only.
        /// </summary>
        public object CurrentOpContext
        {
            get;
            set;
        }

        /// <summary>
        /// Internal user only.
        /// </summary>
        public object CurrentConnection
        {
            get;
            set;
        }

        /// <summary>
        /// Internal user only.
        /// </summary>
        public object CurrentTransaction
        {
            get;
            set;
        }

        /// <summary>
        /// To prevent unintensional overwriting of existing data, a client created entity (i.e. it is not "IsPersisted") can not
        /// be updated to the data source if an existing entity is found to have exactly the same set of "Intrinsic Identifiers". A client
        /// can override this behavior by seting <c>OverrideExisting</c> to <c>true</c> value.
        /// </summary>
        [DataMember]
        public bool OverrideExisting
        {
            get;
            set;
        }

        /// <summary>
        /// Whether or not to ignore invalide items in add or update operations
        /// </summary>
        /// <remarks>
        ///  The ignored item will be reported back to client.
        /// </remarks>
        [DataMember]
        public bool IgnoreInvalideItems
        {
            get { return _ignoreInvalideItems; }
            set { _ignoreInvalideItems = value; }
        }
        private bool _ignoreInvalideItems = false;

        /// <summary>
        /// If the present entity set has a (sync) update timestamp, It indicates whether or not to update the time-stamp field.
        /// </summary>
        [DataMember]
        public bool UpdateSyncTimeStamp
        {
            get { return _updateSyncTimeStamp; }
            set { _updateSyncTimeStamp = value; }
        }
        private bool _updateSyncTimeStamp = true;

        /// <summary>
        /// When a data set has (sync) update timestamp, it allows forceful update of a local modified entity into the data set even when 
        /// a concurrent update conflict is detected.
        /// </summary>
        [DataMember]
        public bool DisableSyncConflictCheck
        {
            get;
            set;
        }

        /// <summary>
        /// When concurrency cache is enabled, setting <c>DirectDataAccess</c> to true will enable the client bypass the cache to have direct
        /// access to the backend data. The default value for it is <c>false</c>.
        /// </summary>
        [DataMember]
        public bool DirectDataAccess
        {
            get;
            set;
        }

        /// <summary>
        /// Whether or not to use a transaction in add, update or delete operations. The default is true.
        /// </summary>
        [DataMember]
        public bool UpdateTransaction
        {
            get { return _updateTransaction; }
            set { _updateTransaction = value; }
        }
        private bool _updateTransaction = true;

        /// <summary>
        /// The service is multi-lingual. A client can specify a preferred set of languages to communicate with the service.
        /// </summary>
        [DataMember]
        public string AcceptLanguages
        {
            get;
            set;
        }

        /// <summary>
        /// Internal use only.
        /// </summary>
        public OperationResults OpResults
        {
            get;
            set;
        }

        /// <summary>
        /// Create a new copy of the CallContext so that client can make per-call customization.
        /// </summary>
        /// <returns>
        /// A new copy of the call context.
        /// </returns>
        public CallContext CreateCopy()
        {
            CallContext c = new CallContext();
            c.CallerID = CallerID;
            c.SessionID = SessionID;
            c.SecurityTicket = SecurityTicket;
            c._filterExprTable_ = _filterExprTable_;
            c.OverrideExisting = OverrideExisting;
            c.DirectDataAccess = DirectDataAccess;
            c.AcceptLanguages = AcceptLanguages;
            return c;
        }

        /// <summary>
        /// Internal use only.
        /// </summary>
        public string InVokePath
        {
            get;
            set;
        }

        /// <summary>
        /// Internal use only.
        /// </summary>
        /// <param name="node">.</param>
        /// <returns>
        /// </returns>
        public void PushInvokeNode(string node)
        {
            if (string.IsNullOrEmpty(InVokePath))
                InVokePath = node;
            else
                InVokePath += "." + node;
        }

        /// <summary>
        /// Internal use only.
        /// </summary>
        /// <returns>
        /// </returns>
        public void PopInvokeNode()
        {
            if (string.IsNullOrEmpty(InVokePath))
                return;
            int ipos = InVokePath.LastIndexOf('.');
            if (ipos == -1)
                InVokePath = "";
            else
                InVokePath = InVokePath.Substring(0, ipos);
        }

        /// <summary>
        /// Get a serialized json representation of the current object.
        /// </summary>
        /// <returns>
        /// The serialized json representation of the current object.
        /// </returns>
        public string ToJson()
        {
            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(CallContext));
            System.IO.MemoryStream strm = new System.IO.MemoryStream();
            ser.WriteObject(strm, this);
            string json = System.Text.Encoding.UTF8.GetString(strm.ToArray());
            return json;
        }

        //todo: add relevant contents
    }

    /// <summary>
    /// A class representing the result of Modifying Operation.
    /// </summary>
    [DataContract]
    public class ChangeOpResults<Entity> where Entity : class
    {
        /// <summary>
        /// Operation messages, if any.
        /// </summary>
        [DataMember]
        public OperationResults OpMsgs
        {
            get;
            set;
        }

        /// <summary>
        /// Entities modified.
        /// </summary>
        [DataMember]
        public Entity[] ChangedEntities
        {
            get;
            set;
        }

        /// <summary>
        /// Entities that are in conflict with newer data in the data store
        /// </summary>
        [DataMember]
        public Entity[] ConflictEntities
        {
            get;
            set;
        }

    }
}