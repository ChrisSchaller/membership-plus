//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Tool name: CGW X-Script Linq to SQL Layer Generator
//
//     Archymeta Information Technologies Co., Ltd.
//
//     Changes to this file, especially those bit flags, may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Configuration;
using System.Data.Linq;
using System.Data.Linq.Mapping;
using System.Data;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Reflection;
using System.Linq;
using System.Linq.Expressions;
using System.ComponentModel;
using System.ServiceModel;
using System.ServiceModel.Channels;

namespace CryptoGateway.RDB.Data.MembershipPlus
{
    /// <summary>
    /// Proxy for <see cref="IUserService2" /> service.
    /// </summary>
    /// <remarks>
    ///  <para>
    ///    Methods of the service are categorized in the following:
    ///  </para>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Adding, Updating or Removing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Adding, updating or removing entity graphs to or from data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="UserServiceProxy.AddOrUpdateEntities" />, <see cref="UserServiceProxy.EnqueueNewOrUpdateEntities" />, and <see cref="UserServiceProxy.DeleteEntities" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Paged Listing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides paged listing of query results.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="UserServiceProxy.NextPageBlock" /> and <see cref="UserServiceProxy.GetPageItems" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Query the data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="UserServiceProxy.QueryEntityCount" />, <see cref="UserServiceProxy.QueryDatabase" />, <see cref="UserServiceProxy.QueryDatabaseLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity Lookup</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Find an entity from the corresponding entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="UserServiceProxy.LoadEntityByKey" /> and <see cref="UserServiceProxy.LoadEntityByNature" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying Intelligency</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides a self-complete system for clients to construct query expressions. What completeness means here is that all options are included and 
    ///      no extra (to the query system) options are present.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="UserServiceProxy.GetNextSorterOps" /> and <see cref="UserServiceProxy.GetNextFilterOps" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Downstream Navigation</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load and/or navigates to entity sets that depend on an entity in the current entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="UserServiceProxy.MaterializeAnnouncements" />, <see cref="UserServiceProxy.MaterializeCommunications" />, <see cref="UserServiceProxy.MaterializeEventCalendar_UserIDs" />, <see cref="UserServiceProxy.MaterializeEventCalendar_CreatedUserIDs" />, <see cref="UserServiceProxy.MaterializeMemberNotifications" />, <see cref="UserServiceProxy.MaterializeUserAppMembers" />, <see cref="UserServiceProxy.MaterializeUserAssociation_FromUserIDs" />, <see cref="UserServiceProxy.MaterializeUserAssociation_ToUserIDs" />, <see cref="UserServiceProxy.MaterializeUserAssocInvitation_FromUserIDs" />, <see cref="UserServiceProxy.MaterializeUserAssocInvitation_ToUserIDs" />, <see cref="UserServiceProxy.MaterializeUserDetails" />, <see cref="UserServiceProxy.MaterializeUserGroupMembers" />, <see cref="UserServiceProxy.MaterializeUserProfiles" />, <see cref="UserServiceProxy.MaterializeUsersInRole_UserIDs" />, <see cref="UserServiceProxy.MaterializeUsersInRole_AdminIDs" />, <see cref="UserServiceProxy.MaterializeUsersRoleHistory_UserIDs" />, <see cref="UserServiceProxy.MaterializeUsersRoleHistory_OperatorIDs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity graph building</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load a selected entity graph from the data source starting at an entity having specified primary key(s)
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="UserServiceProxy.LoadEntityGraphRecurs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    /// </remarks>
    public class UserServiceProxy : ClientBase<IUserService2>, IUserService2
    {
        /// <summary>
        /// Constructor.
        /// </summary>
        public UserServiceProxy() 
            : base("HTTP")
        {

        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="svcConfig">The name of the configuration node for the end point.</param>
        public UserServiceProxy(string svcConfig) 
            : base(svcConfig)
        {

        }

        /// <summary>
        /// Initializes a new instance using the specified binding and target address. 
        /// </summary>
        /// <param name="binding">The binding with which to make calls to the service.</param>
        /// <param name="remoteAddress">The address of the service endpoint.</param>
        public UserServiceProxy(Binding binding, EndpointAddress remoteAddress)
            : base(binding, remoteAddress)
        {

        }

        public Action<Exception> DelHandleError = null;
        /// <summary>
        ///   Retrieve information about the entity set: "Users". 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="UserSet" /> data model.
        /// </returns>
        public UserSet GetSetInfo(CallContext cntx, string filter)
        {
            try
            {
                return Channel.GetSetInfo(cntx, filter);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Retrieve information about the entity set: "Users". Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="UserSet" /> data model.
        /// </returns>
        public async System.Threading.Tasks.Task<UserSet> GetSetInfoAsync(CallContext cntx, string filter)
        {
            try
            {
                return await Channel.GetSetInfoAsync(cntx, filter);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Add or update a set of entities to the entity set. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="User" />) is modified or its <see cref="User.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="User.ChangedAnnouncements" />, <see cref="User.ChangedCommunications" />, <see cref="User.ChangedEventCalendar_UserIDs" />, <see cref="User.ChangedEventCalendar_CreatedUserIDs" />, <see cref="User.ChangedMemberNotifications" />, <see cref="User.ChangedUserAppMembers" />, <see cref="User.ChangedUserAssociation_FromUserIDs" />, <see cref="User.ChangedUserAssociation_ToUserIDs" />, <see cref="User.ChangedUserAssocInvitation_FromUserIDs" />, <see cref="User.ChangedUserAssocInvitation_ToUserIDs" />, <see cref="User.ChangedUserDetails" />, <see cref="User.ChangedUserGroupMembers" />, <see cref="User.ChangedUserProfiles" />, <see cref="User.ChangedUsersInRole_UserIDs" />, <see cref="User.ChangedUsersInRole_AdminIDs" />, <see cref="User.ChangedUsersRoleHistory_UserIDs" />, <see cref="User.ChangedUsersRoleHistory_OperatorIDs" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        public ChangeOpResults<UserUpdateResult> AddOrUpdateEntities(CallContext cntx, UserSet set, User[] entities)
        {
            try
            {
                return Channel.AddOrUpdateEntities(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Add or update a set of entities to the entity set. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="User" />) is modified or its <see cref="User.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="User.ChangedAnnouncements" />, <see cref="User.ChangedCommunications" />, <see cref="User.ChangedEventCalendar_UserIDs" />, <see cref="User.ChangedEventCalendar_CreatedUserIDs" />, <see cref="User.ChangedMemberNotifications" />, <see cref="User.ChangedUserAppMembers" />, <see cref="User.ChangedUserAssociation_FromUserIDs" />, <see cref="User.ChangedUserAssociation_ToUserIDs" />, <see cref="User.ChangedUserAssocInvitation_FromUserIDs" />, <see cref="User.ChangedUserAssocInvitation_ToUserIDs" />, <see cref="User.ChangedUserDetails" />, <see cref="User.ChangedUserGroupMembers" />, <see cref="User.ChangedUserProfiles" />, <see cref="User.ChangedUsersInRole_UserIDs" />, <see cref="User.ChangedUsersInRole_AdminIDs" />, <see cref="User.ChangedUsersRoleHistory_UserIDs" />, <see cref="User.ChangedUsersRoleHistory_OperatorIDs" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        public async System.Threading.Tasks.Task<ChangeOpResults<UserUpdateResult>> AddOrUpdateEntitiesAsync(CallContext cntx, UserSet set, User[] entities)
        {
            try
            {
                return await Channel.AddOrUpdateEntitiesAsync(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="User" />) is modified or its <see cref="User.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="User.ChangedAnnouncements" />, <see cref="User.ChangedCommunications" />, <see cref="User.ChangedEventCalendar_UserIDs" />, <see cref="User.ChangedEventCalendar_CreatedUserIDs" />, <see cref="User.ChangedMemberNotifications" />, <see cref="User.ChangedUserAppMembers" />, <see cref="User.ChangedUserAssociation_FromUserIDs" />, <see cref="User.ChangedUserAssociation_ToUserIDs" />, <see cref="User.ChangedUserAssocInvitation_FromUserIDs" />, <see cref="User.ChangedUserAssocInvitation_ToUserIDs" />, <see cref="User.ChangedUserDetails" />, <see cref="User.ChangedUserGroupMembers" />, <see cref="User.ChangedUserProfiles" />, <see cref="User.ChangedUsersInRole_UserIDs" />, <see cref="User.ChangedUsersInRole_AdminIDs" />, <see cref="User.ChangedUsersRoleHistory_UserIDs" />, <see cref="User.ChangedUsersRoleHistory_OperatorIDs" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        public void EnqueueNewOrUpdateEntities(CallContext cntx, UserSet set, User[] entities)
        {
            try
            {
                Channel.EnqueueNewOrUpdateEntities(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="User" />) is modified or its <see cref="User.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="User.ChangedAnnouncements" />, <see cref="User.ChangedCommunications" />, <see cref="User.ChangedEventCalendar_UserIDs" />, <see cref="User.ChangedEventCalendar_CreatedUserIDs" />, <see cref="User.ChangedMemberNotifications" />, <see cref="User.ChangedUserAppMembers" />, <see cref="User.ChangedUserAssociation_FromUserIDs" />, <see cref="User.ChangedUserAssociation_ToUserIDs" />, <see cref="User.ChangedUserAssocInvitation_FromUserIDs" />, <see cref="User.ChangedUserAssocInvitation_ToUserIDs" />, <see cref="User.ChangedUserDetails" />, <see cref="User.ChangedUserGroupMembers" />, <see cref="User.ChangedUserProfiles" />, <see cref="User.ChangedUsersInRole_UserIDs" />, <see cref="User.ChangedUsersInRole_AdminIDs" />, <see cref="User.ChangedUsersRoleHistory_UserIDs" />, <see cref="User.ChangedUsersRoleHistory_OperatorIDs" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        public async System.Threading.Tasks.Task EnqueueNewOrUpdateEntitiesAsync(CallContext cntx, UserSet set, User[] entities)
        {
            try
            {
                await Channel.EnqueueNewOrUpdateEntitiesAsync(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
            }
        }
#endif

        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        public OperationResults DeleteEntities(CallContext cntx, UserSet set, User[] entities)
        {
            try
            {
                return Channel.DeleteEntities(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        public async System.Threading.Tasks.Task<OperationResults> DeleteEntitiesAsync(CallContext cntx, UserSet set, User[] entities)
        {
            try
            {
                return await Channel.DeleteEntitiesAsync(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Get a block of page frames from the entity set "Users" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="UserPageBlock" /> data model for entity set "Users".
        /// </returns>
        public UserPageBlock NextPageBlock(CallContext cntx, UserSet set, QueryExpresion qexpr, User prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return Channel.NextPageBlock(cntx, set, qexpr, prevlast);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC

        /// <summary>
        ///   Get a block of page frames from the entity set "Users" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="UserPageBlock" /> data model for entity set "Users".
        /// </returns>
        public async System.Threading.Tasks.Task<UserPageBlock> NextPageBlockAsync(CallContext cntx, UserSet set, QueryExpresion qexpr, User prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return await Channel.NextPageBlockAsync(cntx, set, qexpr, prevlast);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load entities of a page from the entity set "Users" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="User" /> in set "Users" for the current page defined by "prevlast".
        /// </returns>
        public IEnumerable<User> GetPageItems(CallContext cntx, UserSet set, QueryExpresion qexpr, User prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return Channel.GetPageItems(cntx, set, qexpr, prevlast);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC

        /// <summary>
        ///   Load entities of a page from the entity set "Users" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="User" /> in set "Users" for the current page defined by "prevlast".
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<User>> GetPageItemsAsync(CallContext cntx, UserSet set, QueryExpresion qexpr, User prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return await Channel.GetPageItemsAsync(cntx, set, qexpr, prevlast);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Count the number of entities inside entity set "Users" of the data source under specified filtering condition. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        public Int64 QueryEntityCount(CallContext cntx, UserSet set, QueryExpresion qexpr)
        {
            try
            {
                return Channel.QueryEntityCount(cntx, set, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return default(Int64);
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Count the number of entities inside entity set "Users" of the data source under specified filtering condition. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<Int64> QueryEntityCountAsync(CallContext cntx, UserSet set, QueryExpresion qexpr)
        {
            try
            {
                return await Channel.QueryEntityCountAsync(cntx, set, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return default(Int64);
            }
        }
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="User" /> inside entity set "Users" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public IEnumerable<User> QueryDatabase(CallContext cntx, UserSet set, QueryExpresion qexpr)
        {
            try
            {
                return Channel.QueryDatabase(cntx, set, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="User" /> inside entity set "Users" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<User>> QueryDatabaseAsync(CallContext cntx, UserSet set, QueryExpresion qexpr)
        {
            try
            {
                return await Channel.QueryDatabaseAsync(cntx, set, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="User" /> inside entity set "Users" from the data source under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public IEnumerable<User> QueryDatabaseLimited(CallContext cntx, UserSet set, QueryExpresion qexpr, int maxRecords)
        {
            try
            {
                return Channel.QueryDatabaseLimited(cntx, set, qexpr, maxRecords);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="User" /> inside entity set "Users" from the data source under specified filtering, sorting and max number of returning entities conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<User>> QueryDatabaseLimitedAsync(CallContext cntx, UserSet set, QueryExpresion qexpr, int maxRecords)
        {
            try
            {
                return await Channel.QueryDatabaseLimitedAsync(cntx, set, qexpr, maxRecords);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "Announcements" of type <see cref="AnnouncementSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="AnnouncementSet" />.
        /// </returns>
        public AnnouncementSet MaterializeAnnouncements(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAnnouncements(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "Announcements" of type <see cref="AnnouncementSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="AnnouncementSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<AnnouncementSet> MaterializeAnnouncementsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAnnouncementsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllAnnouncements" of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />).
        /// </returns>
        public IEnumerable<Announcement> MaterializeAllAnnouncements(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllAnnouncements(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllAnnouncements" of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Announcement}" /> (T = <see cref="Announcement" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<Announcement>> MaterializeAllAnnouncementsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllAnnouncementsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "Communications" of type <see cref="CommunicationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationSet" />.
        /// </returns>
        public CommunicationSet MaterializeCommunications(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeCommunications(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "Communications" of type <see cref="CommunicationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="CommunicationSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<CommunicationSet> MaterializeCommunicationsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeCommunicationsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllCommunications" of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />).
        /// </returns>
        public IEnumerable<Communication> MaterializeAllCommunications(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllCommunications(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllCommunications" of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{Communication}" /> (T = <see cref="Communication" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<Communication>> MaterializeAllCommunicationsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllCommunicationsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "EventCalendar_UserIDs" of type <see cref="EventCalendarSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        public EventCalendarSet MaterializeEventCalendar_UserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeEventCalendar_UserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "EventCalendar_UserIDs" of type <see cref="EventCalendarSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<EventCalendarSet> MaterializeEventCalendar_UserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeEventCalendar_UserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendar_UserIDs" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        public IEnumerable<EventCalendar> MaterializeAllEventCalendar_UserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllEventCalendar_UserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendar_UserIDs" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<EventCalendar>> MaterializeAllEventCalendar_UserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllEventCalendar_UserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "EventCalendar_CreatedUserIDs" of type <see cref="EventCalendarSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        public EventCalendarSet MaterializeEventCalendar_CreatedUserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeEventCalendar_CreatedUserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "EventCalendar_CreatedUserIDs" of type <see cref="EventCalendarSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventCalendarSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<EventCalendarSet> MaterializeEventCalendar_CreatedUserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeEventCalendar_CreatedUserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendar_CreatedUserIDs" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        public IEnumerable<EventCalendar> MaterializeAllEventCalendar_CreatedUserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllEventCalendar_CreatedUserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllEventCalendar_CreatedUserIDs" of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventCalendar}" /> (T = <see cref="EventCalendar" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<EventCalendar>> MaterializeAllEventCalendar_CreatedUserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllEventCalendar_CreatedUserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "MemberNotifications" of type <see cref="MemberNotificationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="MemberNotificationSet" />.
        /// </returns>
        public MemberNotificationSet MaterializeMemberNotifications(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeMemberNotifications(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "MemberNotifications" of type <see cref="MemberNotificationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="MemberNotificationSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<MemberNotificationSet> MaterializeMemberNotificationsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeMemberNotificationsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllMemberNotifications" of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />).
        /// </returns>
        public IEnumerable<MemberNotification> MaterializeAllMemberNotifications(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllMemberNotifications(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllMemberNotifications" of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{MemberNotification}" /> (T = <see cref="MemberNotification" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<MemberNotification>> MaterializeAllMemberNotificationsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllMemberNotificationsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAppMembers" of type <see cref="UserAppMemberSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAppMemberSet" />.
        /// </returns>
        public UserAppMemberSet MaterializeUserAppMembers(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUserAppMembers(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAppMembers" of type <see cref="UserAppMemberSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAppMemberSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserAppMemberSet> MaterializeUserAppMembersAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUserAppMembersAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAppMembers" of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />).
        /// </returns>
        public IEnumerable<UserAppMember> MaterializeAllUserAppMembers(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUserAppMembers(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAppMembers" of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAppMember}" /> (T = <see cref="UserAppMember" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserAppMember>> MaterializeAllUserAppMembersAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUserAppMembersAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAssociation_FromUserIDs" of type <see cref="UserAssociationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssociationSet" />.
        /// </returns>
        public UserAssociationSet MaterializeUserAssociation_FromUserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUserAssociation_FromUserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAssociation_FromUserIDs" of type <see cref="UserAssociationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssociationSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserAssociationSet> MaterializeUserAssociation_FromUserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUserAssociation_FromUserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssociation_FromUserIDs" of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />).
        /// </returns>
        public IEnumerable<UserAssociation> MaterializeAllUserAssociation_FromUserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUserAssociation_FromUserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAssociation_FromUserIDs" of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserAssociation>> MaterializeAllUserAssociation_FromUserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUserAssociation_FromUserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of indirectly depending entities "UserAssociation_FromUserID" of type <see cref="UserSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        public UserSet MaterializePersonalRelations(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializePersonalRelations(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of indirectly depending entities "UserAssociation_FromUserID" of type <see cref="UserSet" /> of an entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserSet> MaterializePersonalRelationsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializePersonalRelationsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllPersonalRelations" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        public IEnumerable<User> MaterializeAllPersonalRelations(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllPersonalRelations(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of indirectly depending entities "AllPersonalRelations" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<User>> MaterializeAllPersonalRelationsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllPersonalRelationsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAssociation_ToUserIDs" of type <see cref="UserAssociationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssociationSet" />.
        /// </returns>
        public UserAssociationSet MaterializeUserAssociation_ToUserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUserAssociation_ToUserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAssociation_ToUserIDs" of type <see cref="UserAssociationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssociationSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserAssociationSet> MaterializeUserAssociation_ToUserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUserAssociation_ToUserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssociation_ToUserIDs" of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />).
        /// </returns>
        public IEnumerable<UserAssociation> MaterializeAllUserAssociation_ToUserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUserAssociation_ToUserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAssociation_ToUserIDs" of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssociation}" /> (T = <see cref="UserAssociation" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserAssociation>> MaterializeAllUserAssociation_ToUserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUserAssociation_ToUserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAssocInvitation_FromUserIDs" of type <see cref="UserAssocInvitationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssocInvitationSet" />.
        /// </returns>
        public UserAssocInvitationSet MaterializeUserAssocInvitation_FromUserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUserAssocInvitation_FromUserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAssocInvitation_FromUserIDs" of type <see cref="UserAssocInvitationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssocInvitationSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserAssocInvitationSet> MaterializeUserAssocInvitation_FromUserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUserAssocInvitation_FromUserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssocInvitation_FromUserIDs" of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />).
        /// </returns>
        public IEnumerable<UserAssocInvitation> MaterializeAllUserAssocInvitation_FromUserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUserAssocInvitation_FromUserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAssocInvitation_FromUserIDs" of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserAssocInvitation>> MaterializeAllUserAssocInvitation_FromUserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUserAssocInvitation_FromUserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserAssocInvitation_ToUserIDs" of type <see cref="UserAssocInvitationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssocInvitationSet" />.
        /// </returns>
        public UserAssocInvitationSet MaterializeUserAssocInvitation_ToUserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUserAssocInvitation_ToUserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserAssocInvitation_ToUserIDs" of type <see cref="UserAssocInvitationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserAssocInvitationSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserAssocInvitationSet> MaterializeUserAssocInvitation_ToUserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUserAssocInvitation_ToUserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserAssocInvitation_ToUserIDs" of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />).
        /// </returns>
        public IEnumerable<UserAssocInvitation> MaterializeAllUserAssocInvitation_ToUserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUserAssocInvitation_ToUserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserAssocInvitation_ToUserIDs" of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserAssocInvitation}" /> (T = <see cref="UserAssocInvitation" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserAssocInvitation>> MaterializeAllUserAssocInvitation_ToUserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUserAssocInvitation_ToUserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of indirectly depending entities "UserAssocInvitation_ToUserID" of type <see cref="UserSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        public UserSet MaterializeInvitatingUsers(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeInvitatingUsers(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of indirectly depending entities "UserAssocInvitation_ToUserID" of type <see cref="UserSet" /> of an entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserSet> MaterializeInvitatingUsersAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeInvitatingUsersAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllInvitatingUsers" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        public IEnumerable<User> MaterializeAllInvitatingUsers(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllInvitatingUsers(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of indirectly depending entities "AllInvitatingUsers" of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{User}" /> (T = <see cref="User" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<User>> MaterializeAllInvitatingUsersAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllInvitatingUsersAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserDetails" of type <see cref="UserDetailSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserDetailSet" />.
        /// </returns>
        public UserDetailSet MaterializeUserDetails(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUserDetails(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserDetails" of type <see cref="UserDetailSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserDetailSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserDetailSet> MaterializeUserDetailsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUserDetailsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserDetails" of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />).
        /// </returns>
        public IEnumerable<UserDetail> MaterializeAllUserDetails(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUserDetails(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserDetails" of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserDetail}" /> (T = <see cref="UserDetail" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserDetail>> MaterializeAllUserDetailsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUserDetailsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserGroupMembers" of type <see cref="UserGroupMemberSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserGroupMemberSet" />.
        /// </returns>
        public UserGroupMemberSet MaterializeUserGroupMembers(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUserGroupMembers(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserGroupMembers" of type <see cref="UserGroupMemberSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserGroupMemberSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserGroupMemberSet> MaterializeUserGroupMembersAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUserGroupMembersAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserGroupMembers" of type <see cref="IEnumerable{UserGroupMember}" /> (T = <see cref="UserGroupMember" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserGroupMember}" /> (T = <see cref="UserGroupMember" />).
        /// </returns>
        public IEnumerable<UserGroupMember> MaterializeAllUserGroupMembers(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUserGroupMembers(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserGroupMembers" of type <see cref="IEnumerable{UserGroupMember}" /> (T = <see cref="UserGroupMember" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserGroupMember}" /> (T = <see cref="UserGroupMember" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserGroupMember>> MaterializeAllUserGroupMembersAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUserGroupMembersAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UserProfiles" of type <see cref="UserProfileSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserProfileSet" />.
        /// </returns>
        public UserProfileSet MaterializeUserProfiles(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUserProfiles(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UserProfiles" of type <see cref="UserProfileSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UserProfileSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UserProfileSet> MaterializeUserProfilesAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUserProfilesAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUserProfiles" of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />).
        /// </returns>
        public IEnumerable<UserProfile> MaterializeAllUserProfiles(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUserProfiles(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUserProfiles" of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UserProfile}" /> (T = <see cref="UserProfile" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UserProfile>> MaterializeAllUserProfilesAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUserProfilesAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UsersInRole_UserIDs" of type <see cref="UsersInRoleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersInRoleSet" />.
        /// </returns>
        public UsersInRoleSet MaterializeUsersInRole_UserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUsersInRole_UserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UsersInRole_UserIDs" of type <see cref="UsersInRoleSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersInRoleSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UsersInRoleSet> MaterializeUsersInRole_UserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUsersInRole_UserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUsersInRole_UserIDs" of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />).
        /// </returns>
        public IEnumerable<UsersInRole> MaterializeAllUsersInRole_UserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUsersInRole_UserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUsersInRole_UserIDs" of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UsersInRole>> MaterializeAllUsersInRole_UserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUsersInRole_UserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of indirectly depending entities "UsersInRole_UserID" of type <see cref="RoleSet" /> of an entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="RoleSet" />.
        /// </returns>
        public RoleSet MaterializeRoles(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeRoles(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of indirectly depending entities "UsersInRole_UserID" of type <see cref="RoleSet" /> of an entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship. The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="RoleSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<RoleSet> MaterializeRolesAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeRolesAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of indirectly depending entities "AllRoles" of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />).
        /// </returns>
        public IEnumerable<Role> MaterializeAllRoles(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllRoles(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of indirectly depending entities "AllRoles" of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  Indirect depending entities are those that depend on the entity through a intermediate entity set, most like forming a
        ///  many to many relationship.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="IEnumerable{Role}" /> (T = <see cref="Role" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<Role>> MaterializeAllRolesAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllRolesAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UsersInRole_AdminIDs" of type <see cref="UsersInRoleSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersInRoleSet" />.
        /// </returns>
        public UsersInRoleSet MaterializeUsersInRole_AdminIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUsersInRole_AdminIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UsersInRole_AdminIDs" of type <see cref="UsersInRoleSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersInRoleSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UsersInRoleSet> MaterializeUsersInRole_AdminIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUsersInRole_AdminIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUsersInRole_AdminIDs" of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />).
        /// </returns>
        public IEnumerable<UsersInRole> MaterializeAllUsersInRole_AdminIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUsersInRole_AdminIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUsersInRole_AdminIDs" of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersInRole}" /> (T = <see cref="UsersInRole" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UsersInRole>> MaterializeAllUsersInRole_AdminIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUsersInRole_AdminIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UsersRoleHistory_UserIDs" of type <see cref="UsersRoleHistorySet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersRoleHistorySet" />.
        /// </returns>
        public UsersRoleHistorySet MaterializeUsersRoleHistory_UserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUsersRoleHistory_UserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UsersRoleHistory_UserIDs" of type <see cref="UsersRoleHistorySet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersRoleHistorySet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UsersRoleHistorySet> MaterializeUsersRoleHistory_UserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUsersRoleHistory_UserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUsersRoleHistory_UserIDs" of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />).
        /// </returns>
        public IEnumerable<UsersRoleHistory> MaterializeAllUsersRoleHistory_UserIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUsersRoleHistory_UserIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUsersRoleHistory_UserIDs" of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UsersRoleHistory>> MaterializeAllUsersRoleHistory_UserIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUsersRoleHistory_UserIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "UsersRoleHistory_OperatorIDs" of type <see cref="UsersRoleHistorySet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersRoleHistorySet" />.
        /// </returns>
        public UsersRoleHistorySet MaterializeUsersRoleHistory_OperatorIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeUsersRoleHistory_OperatorIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "UsersRoleHistory_OperatorIDs" of type <see cref="UsersRoleHistorySet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="UsersRoleHistorySet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<UsersRoleHistorySet> MaterializeUsersRoleHistory_OperatorIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeUsersRoleHistory_OperatorIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllUsersRoleHistory_OperatorIDs" of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />).
        /// </returns>
        public IEnumerable<UsersRoleHistory> MaterializeAllUsersRoleHistory_OperatorIDs(CallContext cntx, User entity)
        {
            try
            {
                return Channel.MaterializeAllUsersRoleHistory_OperatorIDs(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllUsersRoleHistory_OperatorIDs" of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{UsersRoleHistory}" /> (T = <see cref="UsersRoleHistory" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<UsersRoleHistory>> MaterializeAllUsersRoleHistory_OperatorIDsAsync(CallContext cntx, User entity)
        {
            try
            {
                return await Channel.MaterializeAllUsersRoleHistory_OperatorIDsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="User.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="User.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        public User LoadEntityByKey(CallContext cntx, string _ID)
        {
            try
            {
                return Channel.LoadEntityByKey(cntx, _ID);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="User.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="User.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        public async System.Threading.Tasks.Task<User> LoadEntityByKeyAsync(CallContext cntx, string _ID)
        {
            try
            {
                return await Channel.LoadEntityByKeyAsync(cntx, _ID);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="User.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="User.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        public User LoadEntityGraphRecurs(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets)
        {
            try
            {
                return Channel.LoadEntityGraphRecurs(cntx, _ID, excludedSets, futherDrillSets);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="User.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="User.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        public async System.Threading.Tasks.Task<User> LoadEntityGraphRecursAsync(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets)
        {
            try
            {
                return await Channel.LoadEntityGraphRecursAsync(cntx, _ID, excludedSets, futherDrillSets);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="User.Username" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_Username">Intrinsic id <see cref="User.Username" />.</param>
        /// <remarks>
        ///  <para>
        ///   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
        ///   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
        ///   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
        ///   system.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   The list of found entities.
        /// </returns>
        public List<User> LoadEntityByNature(CallContext cntx, string _Username)
        {
            try
            {
                return Channel.LoadEntityByNature(cntx, _Username);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="User.Username" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_Username">Intrinsic id <see cref="User.Username" />.</param>
        /// <remarks>
        ///  <para>
        ///   If the intrinsic identifiers are well chosen, the returned entity set should contain zero or one item. This could not be the case
        ///   if the system is attached to an existing database whose data were entered without respecting the rules (namely those entities having the
        ///   same set of intrinsic identifiers should appear only once inside the data source) imposed later by the
        ///   system.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   The list of found entities.
        /// </returns>
        public async System.Threading.Tasks.Task<List<User>> LoadEntityByNatureAsync(CallContext cntx, string _Username)
        {
            try
            {
                return await Channel.LoadEntityByNatureAsync(cntx, _Username);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        public TokenOptions GetNextSorterOps(CallContext cntx, List<QToken> sorters)
        {
            try
            {
                return Channel.GetNextSorterOps(cntx, sorters);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        public async System.Threading.Tasks.Task<TokenOptions> GetNextSorterOpsAsync(CallContext cntx, List<QToken> sorters)
        {
            try
            {
                return await Channel.GetNextSorterOpsAsync(cntx, sorters);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        public TokenOptions GetNextFilterOps(CallContext cntx, QueryExpresion qexpr, string tkstr)
        {
            try
            {
                return Channel.GetNextFilterOps(cntx, qexpr, tkstr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        public async System.Threading.Tasks.Task<TokenOptions> GetNextFilterOpsAsync(CallContext cntx, QueryExpresion qexpr, string tkstr)
        {
            try
            {
                return await Channel.GetNextFilterOpsAsync(cntx, qexpr, tkstr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        private void HandleError(Exception ex)
        {
            if (DelHandleError != null)
                DelHandleError(ex);
            else
                throw new Exception("server exception", ex);
        }
    }
}